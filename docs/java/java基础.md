

## Java 面向对象

### 谈谈对面向过程编程、面向对象编程还有面向切面编程的理解？

面向过程编程：将问题划分为多个步骤，一步一步实现以解决问题。

面向对象编程： 把一个问题分解成多个对象，然后使用这些对象互相配合以解决问题。

面向切面编程：通过预编译方式和运行期**动态代理**实现程序功能的统一维护的一种技术，可以在运行时（或者编译期、类加载时）动态地将代码切入到类的指定方法的指定位置上。



### 封装

封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。

### 继承

继承是使用已存在的类的定义作为基础建立新类的技术，**新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类，**(注意关联设计原则中的里氏替换原则)。通过使用继承我们能够非常方便地复用以前的代码。

关于继承如下 3 点请记住：

1. 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是**父类中的私有属性和方法子类是无法访问，只是拥有。**
2. 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。
3. 子类可以用自己的方式实现父类的方法。



### 多态

在 Java 虚拟机中，一切方法调用在 Class 文件里面存储的都只是符号引用，需要在**类加载期间，甚至到运行期间才能确定目标方法的直接引用。**多态之所以能够被实现，是由字节码指令 **invokevirtual** 的特性决定的，**invokevirtual 指令会在运行时找到对象的实际类型，并调用对应的方法。**而出于性能的考虑，大部分虚拟机会为类在方法区中建立一个虚方法表（invokeinterface 对应接口方法表），使用虚方法表来代替元数据查找以提高性能。

**在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。**



### 抽象类和接口的异同

抽象类：含有 abstract 修饰符的 class 就算抽象类；它既可以有抽象方法，也可以有普通方法，构造方法，静态方法，但是不能有抽象构造方法和抽象静态方法。且如果其子类没有实现其所有的抽象方法，那么该子类也必须是抽象类；**抽象类除了不能实例化之外，和普通的类没有区别**

接口：他可以看成是抽象类的一个特例，使用 interface 修饰符；

内部结构：

​    jdk7：接口只有常量和抽象方法，无构造器

​    **jdk8：接口增加了默认方法和静态方法，无构造器**

 (详见issue:https://github.com/Snailclimb/JavaGuide/issues/146)

存疑：jdk9：接口允许以private修饰的方法，无构造器

**共同点：**

​    **不能实例化；**

**不同点：**

- **抽象类是单继承的，而接口可以多继承（实现），**接口自己本身可以通过extends关键字扩展多个接口。
- **从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。**
- **接口中除了static、final变量，不能有其他变量，而抽象类中则不一定。**

接口方法默认修饰符是public，抽象方法可以有public、protected和default这些修饰符，抽象方法就是为了被重写所以不能使用private关键字修饰。



**抽象类能否实例化，理论依据是什么？**

不能，抽象类是不完整的，某些方法可能只有声明，而没有定义（实现），调用这些方法会出现未知的结果。





## 未归类

### java权限控制

| 修饰词     | 同一个包的类 | 继承类 | 其他类 |
| ---------- | ------------ | ------ | ------ |
| private    | ×            | ×      | ×      |
| 无（默认） | √            | ×      | ×      |
| protected  | √            | √      | ×      |
| public     | √            | √      | √      |

[注意protected](https://blog.51cto.com/zhangjunhd/19287 )

1. 父类的protected成员是包内可见的，并且对子类可见；
2. 若子类与父类不在同一包中，那么在子类中，子类实例可以访问其从父类继承而来的protected方法，而不能访问父类实例的protected方法。

```java
package 1
class MyObject3 {
protected Object clone() throws CloneNotSupportedException {
       return super.clone();
    }
}
 
package 2
public class Test3 extends MyObject3 {
    public static void main(String args[]) {
       MyObject3 obj = new MyObject3();
       obj.clone(); // Compile error.  不能通过父类访问
       Test3 tobj = new Test3();
       tobj.clone();// Complie OK.  可以继承
    }
}
```



### Object、泛型、通配符区别

`?`是一个不确定的类型，通常用于**泛型方法的调用代码和形参**，不能用于定义类和泛型方法。用于读取未知类型容器中的元素

`<?>`

？的默认是实现是? extends Object，表示`?`是继承Object的任意类型。

`<? extends T>` **上限通配**

这里?表示一个未知的类，而T是一个具体的类，在实际使用的时候T需要替换成一个具体的类，表示**实例化的时候泛型参数要是T或T的子类。**

`<? super T>` **下限通配**

这里?表示一个未知的类，而T是一个具体的类，在实际使用的时候T需要替换成一个具体的类，表示**实例化的时候泛型参数要是T或是T的父类。**

i. 在Java集合框架中，对于参数值是未知类型的容器类，只能读取其中元素，不能向其中添加元素， 因为，其类型是未知，所以编译器无法识别添加元素的类型和容器的类型是否兼容，唯一的例外是NULL

ii. 而泛型方法中的泛型参数对象是可修改的，因为类型参数T是确定的（在调用方法时确定）



### xxx 与 yyy 的 异同？辨析

#### throw 与 throws

​    throw：手动抛出异常，一般出现在函数体中；

​    throws：声明方法可能抛出的异常，一般出现在**方法头部**；

#### final 、finally 与 finalize

​    final：用于声明属性，方法和类，**表示属性不可变，方法不可重写，类不可继承；**

​    finally：它是异常处理语句结构的一部分，表示总是会执行；

​    finalize：它是Object类的 一个方法，在 垃圾收集器 执行 的时候会调用被回收对象的此方法，可以重写此方法 提供垃圾收集时代的其他资源回收，例如关闭文件等。jvm 不保证此方法总被调用；

#### Collection 与 Collections

​     Collection：它是接口， 集合类的上级接口，继承与他有关的接口主要有List和Set；

​    Collections：它 是针对集合类的一个帮助类，他提供一系列静态方法实现对各种集合的搜索、排序、线程安全等操作；如 Collections.sort（xxx）；

#### ArrayList 与 LinkedList、Vector

​        ArrayList：对数组进行封装，实现长度可变的数组，和数组采用相同的存储方式，在内存中分配连续的空间。优点在于遍历元素和随机访问元素效率高；多线程不安全；

​        LinkedList：采用双向链表的存储方式，优点在于插入和删除元素效率高；多线程不安全；

​        **Vector：类似于 ArrayList；但其使用了 synchronized 方法**（多线程安全），使得性能上比 ArrayList 差；同时，在数组扩容时， ArrayList 是增加原来的 0.5倍，变成 1.5倍长度，而Vector 是增加 1倍，变成 2倍长度。

​        jdk7：创建 ArrayList 对象时，默认长度为 10，类似饿汉模式

​        jdk8：创建 ArrayList 对象时，默认长度为 0，在你第一次插入数据时，创建一个 长度为10 的数组，类似懒汉模式

#### HashMap、LinkedHashMap、Hashtable、ConcurrentHashMap

​        HashMap是基于哈希表的Map接口的非同步实现（多线程不安全）， 允许使用null值和null键(HashMap最多只允许一条记录的键为null，允许多条记录的值为null)；

​        Hashtable也是一个散列表，它存储的内容是键值对。key和value都不允许为null，Hashtable遇到null，直接返回NullPointerException。 线程安全,几乎所有的public的方法都是synchronized的，较HashMap速度慢。

​        ConcurrentHashMap是弱一致性，也就是说遍历过程中其他线程可能对链表结构做了调整，因此get和containsKey返回的可能是过时的数据。ConcurrentHashMap是基于**分段锁**设计来实现线程安全性，只有在同一个分段内才存在竞态关系，不同的分段锁之间没有锁竞争。

​        LinkedHashMap是HashMap的一个子类，它保留插入顺序，帮助我们实现了有序的HashMap。 其维护一个双向链表，并不是说其除了维护存入的数据，另外维护了一个双向链表对象，而是说其根据重写HashMap的实体类Entry，来实现能够将HashMap的数据组成一个双向列表，其存储的结构还是数组+链表的形式。

​        TreeMap 是一个有序的key-value集合，它是通过红黑树实现的。 该映射根据其键的自然顺序(字母排序)进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。 TreeMap是非线程安全的。

​        jdk7：创建 HashMap对象时，默认长度为 16，类似饿汉模式（内部数据结构是数组加链表）；新加元素时 元素往头部添加

​        jdk8：创建 HashMap对象时，默认长度为 0，在你第一次插入数据时，创建一个 长度为16的数组，类似懒汉模式（内部数据结构是数组加链表再加红黑树）；新加元素时元素往树尾部添加。

转换为红黑树的条件：一个是链表的长度达到8个，一个是数组的长度达到64个

#### http 、 https

​        HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。

​        HTTPS和HTTP的区别主要如下：

​        1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。

​        2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。

​        3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

​        4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

#### json、gson

​        JSON是一种与开发语言无关的,轻量级的数据格式,全称是JavaScript Object Notation,现在几乎每种语言都有处理JSON的API。

​        Gson是Google提供的用来在Java对象和JSON数据之间进行映射的Java类库,可以将一个JSON字符串转成一个Java对象,或者反过来 。

#### == / equals（）

​        java中的数据类型分为两种:

​        一 、基本数据类型:

​         byte、short、int、long、float、double、char、boolean

​          比较它们需要用  ==  ，比较的是它们的值是否相等

​           二、引用数据类型：

​           也就是对基本数据类型的封装，用 == 比较的是它们的内存地址（其实还是比较的基本数据类型，它们的内存地址不就是int吗）。当new的时候，会给它一个新的内存地址，所以再通过==比较，就会返回false;在Object类中的equals方法其实比较的也是内存地址，用==和equals方法比较结果是一样的，但在一些类中把equals方法重写了，如String、Integer等类中，而不是单纯的比较内存地址了，而是比较内容或者值是否相等。

​            这个equals方法不是固定的，有需要的时候，我们根据情况自己重写。

#### cookie / session

​        cookie数据存放在客户的浏览器上，session数据放在服务器上。

​        cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗

​       考虑到安全应当使用session。

​        session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能

​       考虑到减轻服务器性能方面，应当使用COOKIE。

​        单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。

​    所以个人建议：

​           将登陆信息等重要信息存放为SESSION

​           其他信息如果需要保留，可以放在COOKIE中

#### DOM / SAX 解析

​        SAX解析方式：逐行扫描文档，一遍扫描一遍解析。相比于DOM，SAX可以在解析文档的任意时刻停止解析解析，是一种速度更快，更高效的方法。 优点：解析可以立即开始，速度快，没有内存压力 缺点：不能对结点做修改 ；适用于读取 XML文件。

​        DOM解析方式：DOM解析器在解析XML文档时，会把文档中的所有元素，按照其出现的层次关系，解析成一个个Node对象（节点） 优点：把XML文件在内存中构建属性结构，可以遍历和修改节点。 缺点：如果文件比较大，内存有压力，解析的时间会比较长。适用于修改 XML文件

#### stack / queue

​        栈与队列的相同点： 

​            1.都是线性结构。 

​            2.插入操作都是限定在表尾进行。

​            3.都可以通过顺序结构和链式结构实现。

​            4.插入与删除的时间复杂度都是O（1），在空间复杂度上两者也一样。

​            5.多链栈和多链队列的管理模式可以相同。 

​        栈与队列的不同点： 

​            1.删除数据元素的位置不同，栈的删除操作在表尾进行，队列的删除操作在表头进行。 

​            2.应用场景不同；常见栈的应用场景包括括号问题的求解，表达式的转换和求值，函数调用和递归实现，深度优先搜索遍历等；常见的队列的应用场景包括计算机系统中各种资源的管理，消息缓冲器的管理和广度优先搜索遍历等。 

​            3.顺序栈能够实现多栈空间共享，而顺序队列不能。



## 集合 Collection

​        Collection是一个接口，它主要的两个分支是：List 和 Set。

​        List和Set都是接口，它们继承于Collection。List是有序的队列，List中可以有重复的元素；而Set是数学概念中的集合，Set中没有重复元素！

​        List和Set都有它们各自的实现类。

​         为了方便，我们抽象出了AbstractCollection抽象类，它实现了Collection中的绝大部分函数；这样，在Collection的实现类中，我们就可以通过继承AbstractCollection省去重复编码。AbstractList和AbstractSet都继承于AbstractCollection，具体的List实现类继承于AbstractList，而Set的实现类则继承于AbstractSet。

​          另外，Collection中有一个iterator()函数，它的作用是返回一个Iterator接口。通常，我们通过Iterator迭代器来遍历集合。ListIterator是List接口所特有的，在List接口中，通过ListIterator()返回一个ListIterator对象。



## 反射



## I/O
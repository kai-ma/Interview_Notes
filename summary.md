# [Java](docs/java/java-basic.md)

常量池总结

逃逸总结



## Java语言特性

### 反射

**JAVA 反射机制是在运行状态中，对于任意一个类或对象，都能够知道并调用这个类的所有属性和方法；这种动态获取的信息以及动态调用对象的方法的功能称为 java 语言的反射机制。**

**实现原理：对于任意一个类，在JVM第一次读到一种class时，会创建一个对应的Class实例，实例中保存了该class的所有信息——可以知道这个类的所有属性和方法；能通过Class对象，来调用它的任意方法和属性。**

Class类的构造方法是private，这个Class实例是JVM内部创建的，只有JVM能创建Class实例，我们自己的Java程序不可以。

所以，JVM持有的每个Class实例都指向一个数据类型（class或interface）。实例中保存了该class的所有信息，包括类名、包名、父类、实现的接口、所有构造方法、方法、字段等，因此，如果获取了某个Class实例，我们就可以通过这个Class实例获取到该实例对应的class的所有信息，可以通过Class实例创建对象，调用方法，修改字段。

- **优点：** 运行期类型的判断，动态加载类，提高代码灵活度。
- **缺点：** 性能\安全问题

#### 反射的应用场景

**反射是框架设计的灵魂。**

1. JDBC 连接数据库时使用 `Class.forName()`通过反射加载数据库的驱动程序；
2. Spring 框架的 IOC（动态加载管理 Bean）创建对象以及 AOP（动态代理）功能都和反射有联系；
3. 动态配置实例的属性；

#### 获取Class对象的四种方式

通过类获取、通过对象获取、Class.forName(path)，classLoader.loadClass(path)。

#### 反射机制的相关类

| 类名          | 用途                                             |
| ------------- | ------------------------------------------------ |
| Class类       | 代表类的实体，在运行的Java应用程序中表示类和接口 |
| Field类       | 代表类的成员变量（成员变量也称为类的属性）       |
| Method类      | 代表类的方法                                     |
| Constructor类 | 代表类的构造方法                                 |

**反射为何耗性能？ todo**

运行时注解的信息可以在运行时通过反射机制获取

由于反射涉及动态地解析类型，**无法执行 Java 虚拟机的某些优化措施**（比如 JIT？公共子表达式消除？数组范围检查消除？方法内联？逃逸分析？），因此性能低于非反射操作。



### 泛型

泛型是Java SE 1.5的新特性，泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法的创建中，分别称为**泛型类、泛型接口、泛型方法(接受各种类型的参数)。** Java语言引入泛型的好处是**安全简单。**

**泛型的好处是在编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的，以提高代码的重用率。**

**常用的通配符为： T，E，K，V，？**

- ？ 表示不确定的 java 类型
- T (type) 表示具体的一个 java 类型
- K V (key value) 分别代表 java 键值中的 Key Value
- E (element) 代表 Element

`?`是一个不确定的类型，通常用于**泛型方法的调用代码和形参**，不能用于定义类和泛型方法。用于读取未知类型容器中的元素

`<?>`？的默认是实现是? extends Object，表示`?`是继承Object的任意类型。

`<? extends T>` 上限通配，表示实例化的时候泛型参数要是T或T的子类。

`<? super T>` 下限通配，表示实例化的时候泛型参数要是T或是T的父类。

**?通配符和泛型的区别**

在Java集合框架中，对于参数值是未知类型的容器类，**只能读取其中元素，不能向其中添加元素**， 因为，其类型是未知，所以编译器无法识别添加元素的类型和容器的类型是否兼容，唯一的例外是NULL

而泛型方法中的泛型参数对象是可修改的，因为类型参数T是确定的（在调用方法时确定）

#### 泛型擦除

**避免过多的创建类而造成的运行时的过度消耗。**

`ArrayList<String>`和`ArrayList<Integer>`对象的`getClass()`方法获取类信息，用`==`比较，返回是true。说明对于JVM来说，这两种类是同一个类，在编译完成后泛型类型`String`和`Integer`都被擦除掉了，只剩下原始类型`ArrayList`。

当然，想给`ArrayList<String>`添加Integer类型的对象也是可以的，方法当然是在运行期间获取信息的反射了



### 面向对象

[继承、封装、多态的实现原理](https://github.com/h2pl/Java-Tutorial/blob/master/docs/java/basic/23、继承、封装、多态的实现原理.md)

继承类似于组合，子类持有一个父类对象。

和invokeinterface还有invokevirture有关，动态调用子类重写的方法。

#### 多态

运行时多态有三个条件：继承、重写、向上转型

在 Java 虚拟机中，一切方法调用在 Class 文件里面存储的都只是符号引用，需要在**类加载期间，甚至到运行期间才能确定目标方法的直接引用。**多态之所以能够被实现，是由字节码指令 **invokevirtual** 的特性决定的，**invokevirtual 指令会在运行时找到对象的实际类型，并调用对应的方法。**而出于性能的考虑，大部分虚拟机会为类在方法区中建立一个虚方法表（invokeinterface 对应接口方法表），使用虚方法表来代替元数据查找以提高性能。



### 抽象类和接口的异同

抽象类：含有 abstract 修饰符的 class 就算抽象类；它既可以有抽象方法，也可以有普通方法，构造方法，静态方法，但是不能有抽象构造方法和抽象静态方法。且如果其子类没有实现其所有的抽象方法，那么该子类也必须是抽象类；**抽象类除了不能实例化之外，和普通的类没有区别**

接口：可以看成是抽象类的一个特例，使用 interface 修饰符；接口默认的方法是public的，写不写public是一样的。jdk8：接口增加了默认方法和静态方法，无构造器。

**共同点：**

​    **不能实例化；**都是不完整的，某些方法可能只有声明，而没有定义（实现），调用这些方法会出现未知的结果。

**不同点：**

- **抽象类是单继承的，而接口可以多继承（实现），**接口自己本身也可以通过extends关键字扩展多个接口。
- **从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。**
- **接口中除了static、final变量，不能有其他变量，而抽象类中则不一定。**

接口方法默认修饰符是public，抽象方法可以有public、protected和default这些修饰符，抽象方法就是为了被重写所以不能使用private关键字修饰。



## Collection

#### Arraylist 与 LinkedList 区别

1. **是否保证线程安全：** `ArrayList` 和 `LinkedList` 都是不同步的，也就是都不保证线程安全；
2. **底层数据结构：** `Arraylist` 底层使用的是 **`Object` 数组**；`LinkedList` 底层使用的是 **双向链表** 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。）
3. **插入和删除是否受元素位置的影响：** ① **`ArrayList` 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。** ② **`LinkedList` 采用链表存储，所以对于`add(E e)`方法的插入，删除元素时间复杂度不受元素位置的影响，近似 O(1)，如果是要在指定位置`i`插入和删除元素的话（`(add(int index, E element)`） 时间复杂度近似为`o(n))`因为需要先移动到指定位置再插入。**
4. **是否支持快速随机访问：** `LinkedList` 不支持高效的随机元素访问，而 `ArrayList` 支持。
5. **内存空间占用：** ArrayList 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。



### HashMap

**java为数据结构中的映射定义了一个接口java.util.Map;它有四个实现类,分别是HashMap Hashtable LinkedHashMap 和TreeMap.**

JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。

JDK1.8 之后 HashMap 的组成多了红黑树，在链表长度大于阈值（默认为 8）且 HashMap 数组长度超过 64 之后，会执行链表转红黑树操作，以此来加快搜索速度。

#### 辨析

##### HashMap 和 TreeMap 区别

**TreeMap底层是红黑树，复杂度是O(logN)**

`TreeMap` 和`HashMap` 都继承自`AbstractMap` ，但是需要注意的是`TreeMap`它还实现了`NavigableMap`接口和`SortedMap` 接口。

实现 `NavigableMap` 接口让 `TreeMap` 有了对集合内元素的搜索的能力。比如`floorKey(K key);``K ceilingKey(K key);`这些方法。

实现`SortMap`接口让 `TreeMap` 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序，不过我们也可以指定排序的比较器。

#### HashMap 和 Hashtable 的区别

1. **线程是否安全：** `HashMap` 是非线程安全的，`HashTable` 是线程安全的，因为 `HashTable` 内部的方法基本都经过`synchronized` 修饰。；
2. **效率：** 因为线程安全的问题，`HashMap` 要比 `HashTable` 效率高一点。另外，`HashTable` 基本被淘汰，不要在代码中使用它；
3. **对 Null key 和 Null value 的支持：** `HashMap` 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；HashTable 不允许有 null 键和 null 值，否则会抛出 `NullPointerException`。
4. **初始容量大小和每次扩充容量大小的不同 ：** ① 创建时如果不指定容量初始值，`Hashtable` 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。`HashMap` 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 `HashMap` 会将其扩充为 2 的幂次方大小（`HashMap` 中的`tableSizeFor()`方法保证）。
5. **底层数据结构：** JDK1.8 以后的 `HashMap` 在解决哈希冲突时有了较大的变化，达到条件会将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。

##### map下有哪些线程安全？

HashTable，ConcurrentHashMap，ConcurrentSkipListMap。推荐使用ConcurrentHashMap，首先，HashTable 是一个过时的类，不应该再使用了。

##### ConcurrentHashMap和Hashtable的区别

`ConcurrentHashMap` 和 `Hashtable` 的区别主要体现在实现线程安全的方式上不同。

- **底层数据结构：**
  - `ConcurrentHashMap` 
    - JDK1.7  **分段的数组+链表** 
    - JDK1.8，**数组+链表/红黑二叉树。** 与HashMap1.8相同
  - `Hashtable`  **数组+链表**  一直没变
- **实现线程安全的方式（重要）：** 
  -  `ConcurrentHashMap` 
     - JDK1.7 分段锁：Segment 实现了 `ReentrantLock`，所以 `Segment` 是一种可重入锁，扮演锁的角色。
     - JDK1.8 并发控制使用 `synchronized` 和 CAS 来操作，`synchronized` 只锁定当前链表或红黑二叉树的首节点。   不同段没有竞争——>不hash冲突就没有锁竞争 
  -  **`Hashtable`(同一把锁)**：全表锁，使用 `synchronized` 来保证线程安全，效率非常低下。不同线程抢占资源，抢不到的阻塞或轮询

##### LinkedHashMap

LinkedHashMap 是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录是先插入的，如果用LRU，Iterator.next第一个就是最先插入的，空间满了应该先被淘汰。



#### HashMap中key和value可以为null吗？允许几个为null呀？

**hashtable不可以（一般线程安全的都不可以），hashmap的key可以有一个，value可以有无限个null。**

##### HashTable为什么不支持null

当时设计的时候，是约定要从Hashtable成功存储和检索对象，用作键的对象必须实现hashCode方法和equals方法。

由于null不是对象，因此不能在其上调用.equals()或.hashCode()，因此Hashtable无法将其计算哈希值以用作键。

**补充：支持多线程的一般都不允许null**

举例：ConcurrentHashMap不能put null 是因为无法分辨是key没找到的null还是有key值为null，这在多线程里面是模糊不清的，所以压根就不让put null。

#### HashMap 和 TreeMap 区别

`TreeMap` 和`HashMap` 都继承自`AbstractMap` ，但是需要注意的是`TreeMap`它还实现了`NavigableMap`接口和`SortedMap` 接口。

**TreeMap的实现是红黑树。**

实现`SortedMap` 接口让`TreeMap`有了排序的能力。默认是按 key 的升序排序，也可以指定排序的比较器。

实现 `NavigableMap` 接口让 `TreeMap` 有了对集合内元素的搜索的能力。比如`floorKey(K key);``K ceilingKey(K key);`这些方法。

#### LinkedHashMap 和 HashMap

HashMap和双向链表合二为一即是LinkedHashMap。LinkedHashMap是HashMap的子类，所以LinkedHashMap自然会拥有HashMap的所有特性。put每次都在末尾，可以用`map.entrySet().iterator();`顺序遍历entry。

LinkedHashMap可以很好的支持LRU算法。



#### 扩容机制

**一般要讲链表红黑树、负载因子、其他哈希解决冲突方法**

创建HashMap对象默认情况下，数组大小为16。

##### 负载因子/扩容因子

**`开始扩容的大小 = 原来的数组大小 * 负载因子 - loadFactor`**   16*0.75=12 超过12个元素，进行扩容。

loadFactor控制数组存放数据的疏密程度。越大越密集，越小越稀疏。太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor 的默认值为 0.75f 是官方给出的一个比较好的临界值。

扩容后大小是原来的2倍-数组大小永远是2的幂次。

进行扩容，会伴随着一次重新 hash 分配，并且会遍历 hash 表中所有的元素，是非常耗时的。在编写程序中，要尽量避免 resize。如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。因此阿里巴巴规范中要求HashMap要设置初始值。



#### Hash计算

**为什么要右移16位？**

扰动函数hash()：防止一些实现比较差的 hashCode() 方法，减少碰撞。算下标的时候只有hash的低16位参与了运算（数组的大小有限），所以hashCode得到的int值把高16位和低16位进行了一个异或，等于说计算下标时把hash的高16位也参与进来了，减少了hash碰撞。

##### HashMap 的长度为什么是 2 的幂次方

Hash值的范围是int范围，用之前还要先做对数组的长度取模运算。数组长度n为2的幂次时，取模运算非常简单：`(n - 1) & hash`。相对于%能够提高运算效率

##### 重写 `equals` 时必须重写 `hashCode` 方法？

**保证如果两个对象相等，则 hashcode 一定也是相同的。这是规定。**否则当把这个对象放入`HashMap`，有可能添加重复key。

#### 其他哈希解决冲突方法

**开放地址法（找到下一个为空的）  再hash法    公共溢出区方法（所有冲突的都放到溢出区）**



#### HashMap死循环问题

多线程并发下的扩容操作，两个线程都进行扩容，都创立了一个新数组。对于有hash冲突的位置，链表长度不止为1，两个线程都对链表进行操作，可能形成**循环链表。**然后get的时候在链表中循环，出不来。



## 常用类

### String

#### String、StringBuffer、StringBuilder的区别

[String，StringBuilder，StringBuffer 实现原理解析](https://www.jianshu.com/p/64519f1b1137)

可变性、线程安全、性能

`String` 类中使用 final 关键字修饰字符数组来保存字符串，`private final char value[]`，所以**`String` 对象是不可变的。**而 `StringBuilder` 与 `StringBuffer` 这两种对象都是可变的。

`String` 中的对象是不可变的，也就可以理解为常量，线程安全。`StringBuffer` 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。`StringBuilder` 并没有对方法进行加同步锁，所以是非线程安全的。

每次对 `String` 类型进行改变的时候，都会生成一个新的 `String` 对象，然后将指针指向新的 `String` 对象。`StringBuffer` 每次都会对 `StringBuffer` 对象本身进行操作，而不是生成新的对象并改变对象引用。其append拼接字符串方法内部调用System的native方法，进行数组的拷贝，不会重新生成新的StringBuilder对象。相同情况下使用 `StringBuilder` 相比使用 `StringBuffer` 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。

**对于三者使用的总结：**

1. 操作少量的数据: 适用 `String`
2. 单线程操作字符串缓冲区下操作大量数据: 适用 `StringBuilder`
3. 多线程操作字符串缓冲区下操作大量数据: 适用 `StringBuffer`



### 包装类

#### 自动装箱与拆箱

- **装箱**：将基本类型用它们对应的引用类型包装起来；
- **拆箱**：将包装类型转换为基本数据类型；

```java
Integer i = new Integer(10); //Java SE5之前只支持这种写法。

//Java SE5之后可以这么写，根据数值创建对应的 Integer对象，这就是装箱。
Integer i = 10;  //装箱
int n = i;   //拆箱
```

从反编译得到的字节码内容可以看出，**在装箱的时候自动调用的是Integer的`valueOf(int)`方法。而在拆箱的时候自动调用的是Integer的`intValue`方法。**

#### 常量池

Java 基本类型的包装类的大部分都实现了常量池技术，即 Byte,Short,Integer,Long,Character,Boolean；前面 4 种包装类默认创建了数值[-128，127] 的相应类型的缓存数据。

**所有整型包装类对象值的比较必须使用equals方法。**如果不显示地用new，而用自动装箱方式创建包装类对象的时候，小于缓存区间，用的是同一个对象，超出缓存区间范围，使用的是不同的对象。如果用new，永远不会是同一个对象。

**为啥把缓存设置为[-128，127]区间？性能和资源之间的权衡。**

**Integer 比较更丰富的一个例子:**

```java
Integer i1 = 40;
Integer i2 = 40;
Integer i3 = 0;
Integer i4 = new Integer(40);
Integer i5 = new Integer(40);
Integer i6 = new Integer(0);

i1==i2   true
i1==i2+i3   true
i1==i4   false
i4==i5   false
i4==i5+i6   true
40==i5+i6   true
```

解释：

语句 i4 == i5 + i6，**因为+这个操作符不适用于 Integer 对象，首先 i5 和 i6 进行自动拆箱操作**，进行数值相加，即 i4 == 40。然后 Integer 对象无法与数值进行直接比较，所以 i4 自动拆箱转为 int 值 40，最终这条语句转为 40 == 40 进行数值比较。

## I/O

java client端的socket write所有字节流iput到字节流的tcpip缓冲区，java client才能返回。如果网络传输很慢，tcp ip缓冲区塞满，java client必须等待缓冲区有空间，写完才可能返回。

java的nio就借用了epoll的思想，虽然jdk只支持select模型，但是在linux2.6的内核以上，jdk的源码是直接用的epoll的模型。著名的NIO框架netty，就是基于epoll模型完成多路复用机制。





# Java多线程

- [ ] 总结AQS
- [ ] 精炼多线程
- [ ] 

### Thread

==**Runnable传参，也就是怎么注入属性？**==

Setter或者Constructor

传参有了，怎么返回结果呢？

Callable返回`Future`对象。如果很多个任务并发执行，最终统计结果，可以把结果放到`List<Future>`中，然后遍历List，future.get()获取每个子任务的结果。



### 线程安全的实现方式

>  避免多线程竞争时有哪些手段？

**1) 不可变对象；**

**2) 互斥锁；**

**3) ThreadLocal 对象；** 空间换时间

**4) CAS；**

#### ThreadLocal

**ThreadLocal即线程本地存储，ThreadLocal会为每一个线程提供一个独立的变量副本，因此避免了多线程竞争。**



## JUC中的容器

![juc中的并发容器](images/summary/JUC Collection.png)

#### ConcurrentHashMap 🔥

线程安全的HashMap

JDK1.7  分段的数组+链表。JDK1.8之后，数组+链表/红黑二叉树，与HashMap1.8相同。

实现：从不同段没有竞争到不hash冲突就没有锁竞争。JDK1.7 分段锁，Segment 实现了 `ReentrantLock`。JDK1.8 并发控制使用 `synchronized` 和 CAS 来操作，`synchronized` 只锁定当前链表或红黑二叉树的首节点。   

1.8之后底层原理：

- get方法无锁实现，原因：Node的value，next都用volatile修饰。table[]也用volatile修饰，保证了修改的可见性。 
- put方法，先读tabAt，若bucket为空，for循环+CAS。若不为空，如果正在扩容，当前线程帮助一起扩容。如果没有扩容，用synchronized锁住这个结点位置。其余bucket可以并发执行。
- remove方法，先读tabAt，若bucket为空退出for循环。若不为空，如果正在扩容，当前线程帮助一起扩容。如果没有扩容，用synchronized锁，锁的粒度是结点锁，锁住这个bucket的操作。其余bucket可以并发执行。
- 扩容 transfer方法，非常非常巧妙的并行扩容。

读读互不影响，写写互斥。读写也不互斥，不过在某些情况下读取是弱一致性的，如线程A调用putAll写入大量数据，期间线程B调用get，则只能get到目前为止已经顺利插入的部分数据。这也是为什么ConcurrentHashMap不能完全替代HashTable。

#### CopyOnWriteArrayList/CopyOnWriteArraySet

线程安全的ArrayList/Set

`CopyOnWriteArrayList` 支持读写分离，读取是快照读，与MVCC原理一样，完全不用加锁。写入操作不会修改原数组，而是拷贝一个数组，对副本进行修改，写完之后再将内部维护的数组指向新的数组。因此读写互不影响，只有写写才会互斥。适合于多读，少写场景（不断创建副本/写操作要加锁），小对象场景。

缺点：大对象内存占用严重。读操作与使用迭代器是弱一致性的，读不到新写入的数据。

`CopyOnWriteArraySet`底层使用`CopyOnWriteArrayList` ，性质相同。

#### ConcurrentLinkedQueue

线程安全的LinkedList，线程安全的非阻塞队列。

线程安全的队列分为阻塞队列和非阻塞队列，阻塞队列通过加锁来实现，非阻塞队列通过 CAS 操作实现。`ConcurrentLinkedQueue` 用CAS+volatile实现了非阻塞的链表队列，适用于高并发追求高性能的场景。与阻塞队列相比的优缺点和CAS与锁的优缺点分析一样。

`ConcurrentLinkedDeque`与它类似，是线程安全的 `Deque`。

#### BlockingQueue

常用的三个实现类：`ArrayBlockingQueue`、`LinkedBlockingQueue`、`PriorityBlockingQueue`。都使用`ReentrantLock`。

`ArrayBlockingQueue`有界，采用经典的双Condition实现，默认非公平，可选择公平锁。

`LinkedBlockingQueue`单向链表，默认无界，初始化可以指定边界，不支持公平锁。

`PriorityBlockingQueue`无界，可以指定初始化大小，但会动态扩容。要么是Comparable的，要么传入Comparator。

还有一种：`SynchronousQueue`，在`CachedThreadPool`会用到。虽说是队列，但不会为队列中元素维护存储空间。是同步队列，读线程和写线程需要同步，一个读线程匹配一个写线程。数据必须从某个写线程交给某个读线程，而不是写到某个队列中等待被消费。

#### ConcurrentSkipListMap

依靠CAS实现线程安全，底层是跳表结构，用空间换时间。有序场景下比CurrentHashMap效率高。



## AQS

```java
public final void acquire(int arg) {
    if (!tryAcquire(arg) &&
        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
```



##### 线程释放锁过程：

1. tryRelease()来释放资源。
2. 用unpark()唤醒等待队列中最前边的那个未放弃线程。



# [JVM](docs/java/jvm.md)

可以通过 -Xss 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小，在 JDK 1.4 中默认为 256K，**而在 JDK 1.5+ 默认为 1M：**

```sh
java -Xss2M HackTheJava
```

### JVM有哪些组成部分，各部分的主要功能

Java虚拟机主要分为5大模块，**类装载器子系统，运行时数据区，执行引擎，本地方法接口，垃圾收集模块。**

**各部分主要功能:**

**类加载器**：负责将class字节码加载到JVM内存区域中（需要符合格式要求，具体过程详见类加载机制）。

**执行引擎**：负责解析、执行文件中包含的字节码指令（解释执行，即时编译，OSR）

**运行时数据区（JVM内存模型）**：

- 方法区(元空间)：用于存储类结构信息的地方，包括常量池、静态变量、构造函数等
- Java堆（Heap）：存储java实例的地方。这块是GC的主要区域。方法区和堆是被线程共享的。
- Java栈（Stack）：java栈总是和线程关联在一起，每当创建一个线程时，JVM就会为这个线程创建一个对应的java栈。每运行一个方法就创建一个栈贞，用于存储局部变量表、操作栈，方法返回等。
- 程序计数器（PC Register）：一块较小的内存空间，可以看做是当前线程所执行的字节码行号指示器，分支，循环，跳转，异常处理，线程恢复等基础功能都需要一来这个计数器来完成。
- 本地方法栈（Native Method Stack）：和java栈作用差不多，只不过是为JVM使用到的本地方法服务。

**本地方法接口**：主要提供调用C或C++实现的本地方法。特别是操作系统相关，底层相关。融合不同开发语言的原生库为Java所用（C、C++更高效；不重复造轮子）

**垃圾回收模块**：主要负责方法区和堆的垃圾回收。

## JVM内存区域

**线程私有：程序计数器、虚拟机栈、本地方法栈。**

**共有：堆、方法区(永久代->元空间)**

### 程序计数器

流程控制，如：顺序执行、选择、循环、异常处理。多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。

程序计数器是**唯一一个不会出现** **OutOfMemoryError** **的内存区域**，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。

### Java 虚拟机栈

可以通过 -Xss 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小，在 JDK 1.4 中默认为 256K，**而在 JDK 1.5+ 默认为 1M：**

```sh
java -Xss2M HackTheJava
```

### 方法区

用于存放已被加载的**类信息（method、field）、类文件、常量、静态变量等数据。**

方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式。**在JDK8之后，用元空间替代了永久代。**原来永久代的数据被分到了堆和元空间中。静态变量和字符串常量池等放入堆中，类的元信息放在元空间中。**元空间使用的是直接内存。**

运行时常量池和字符串常量池不同，存放符号引用，在元空间中。

元空间大小默认值为 unlimited，这意味着它只受系统内存的限制。

```sh
-XX:MetaspaceSize=N //设置 Metaspace 的初始（和最小大小）
-XX:MaxMetaspaceSize=N //设置 Metaspace 的最大大小
```

#### 方法区和堆之间的关系

**方法区中的静态的引用类型的变量存的是堆中的地址，指向堆中的对象。**

#### 元空间(MetaSpace)相比永久代(PermGen)的优势

- 整个永久代有一个 JVM 本身设置固定大小上限，无法进行调整，而**元空间使用的是直接内存**，受本机可用内存的限制，可以加载更多的类，且出现OOM的几率会更小。
- 字符串常量池存在永久代中，若频繁调用intern()，容易出现性能问题和OOM。字符串常量池放在了堆中就没有这个问题了。由堆的GC管理字符串常量池，方便对字符串常量池的回收。
- 类和方法的信息大小难以确定，给永久代的大小指定带来困难。太小，容易导致永久代溢出，太大容易导致老年代溢出。



## 类加载

### 类加载过程

加载、连接（验证、准备、解析）、初始化、使用、卸载

#### 加载

**通过ClassLoader加载class字节码文件，生成Class对象。**

通过-XX:+TraceClassLoading参数可以观察

类加载过程的第一步，主要完成下面3件事情：

1. **通过类的全限定名获取定义这个类的二进制字节流**
2. **将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构**
3. **在内存(Java堆)中生成一个代表这个类的 java.lang.Class 对象，作为方法区这些数据的访问入口**

一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以**自定义类加载器**去控制字节流的获取方式（**重写一个类加载器的 loadClass() 方法**）。数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。

#### 验证

**确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。**

#### 准备

**为类变量分配内存并设置初始值。**

**类变量是被static修饰的变量**。实例变量不会在这阶段分配内存，实例变量会在对象实例化时随着对象一块分配在 Java 堆中。应该注意到，实例化不是类加载的一个过程，**类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。实例化-对象创建的过程在后面的JVM内存区部分。**

#### 解析

**解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。**——静态解析

**Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。**当需要调用一个类的方法的时候，只要知道这个方法在方发表中的偏移量就可以直接调用该方法了。**通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。**

#### 初始化

**执行类变量赋值和静态代码块。**

#### 什么时候会进行类的初始化——主动引用？

对于初始化阶段，虚拟机严格规范了有且只有6种情况下，必须对类进行初始化(只有主动去使用类才会初始化类)：

- 当遇到 new 、 getstatic、putstatic或invokestatic 这4条直接码指令时，比如 new 一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时。最常见的生成这 4 条指令的场景是：使用 new 关键字实例化对象的时候；读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候；以及调用一个类的静态方法的时候。
- 使用 java.lang.reflect 包的方法对类进行反射调用时如Class.forname("..."),newInstance()等等，如果类没初始化，需要触发其初始化。
- 初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。
- 当虚拟机启动时，用户需要定义一个要执行的主类 (包含 main 方法的那个类)，虚拟机会先初始化这个类。
- MethodHandle和VarHandle可以看作是轻量级的反射调用机制，而要想使用这2个调用， 就必须先使用findStaticVarHandle来初始化要调用的类。
- 当一个接口中定义了JDK8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。

#### 结束

在如下几种情况JVM将结束生命周期

- 执行了System.exit(0)方法
- 程序正常执行结束
- 程序再执行过程中遇到了异常或错误而异常终止
- 由于操作系统出现错误而导致JVM虚拟机进程终止

### 类加载器与双亲委派模型

**类加载器作用：在Class装载的加载阶段，从Class文件中的二进制数据流装载进系统。**

#### forName()和loadClass()区别

**forName()会初始化类：会进行类变量赋值和执行静态代码块。loadClass只进行了加载过程，第二步的链接和初始化都没有进行。**

```java
@CallerSensitive
public static Class<?> forName(String className)
    throws ClassNotFoundException {
    Class<?> caller = Reflection.getCallerClass();
    return forName0(className, true, ClassLoader.getClassLoader(caller), caller);
}
```

**Class.forName()默认`initialize`传true，会初始化。会解析-会执行静态代码块。**JDBC，因为driver中有静态语句块需要被执行：生成Driver对象，创建数据库驱动。

```java
public Class<?> loadClass(String name) throws ClassNotFoundException {
    return loadClass(name, false);
}
```

**classLoader.loadClass()的参数`resolve`传false，不会进行解析和初始化。**

#### 类加载器

1. BootstrapClassLoader(启动类加载器) ：最顶层的加载类，由C++实现，负责加载 **%JAVA_HOME%/lib**目录下的jar包和类或者或被 -Xbootclasspath参数指定的路径中的所有类库。
2. ExtensionClassLoader(扩展类加载器，JKD1.9之后为PlatformClassLoader) ：主要负责加载目录 **%JRE_HOME%/lib/ext** 目录下的jar包和类，或被 java.ext.dirs 系统变量所指定的路径下的jar包。
3. AppClassLoader(应用程序类加载器) :面向我们用户的加载器，负责加载**当前应用classpath下的所有jar包和类**。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为系统类加载器。如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

#### 双亲委派模型

加载时一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载。

双亲委派模型的实现代码逻辑非常清晰，在java.lang.ClassLoader的loadClass() 中，先检查类是否已经加载过，如果没有则让父类加载器去加载，看起来像递归一样。当父类加载器加载失败时抛出 

##### 双亲委派模型的好处

**1.** **可以避免类的重复加载**。通过委托去向上面问一问，加载过了，就不用再加载一遍。保证数据安全。

**2. 保证了 Java 的核心类库不被篡改**，保证了Class执行安全。通过委托方式，不会去篡改核心.clas，即使篡改也不会去加载，即使加载也不会是同一个.class对象了。

##### 同一个类 被两个不同的类加载器加载 它们会被当成同一个类吗 

**不会**   JVM 区分不同类的方式不仅仅根据类名，**相同的类文件被不同的类加载器加载产生的是两个不同的类。**会在方法区产生两个不同的类，彼此不可见，并且在堆中生成不同Class实例。

##### 自定义类加载器的实现

- 除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自java.lang.ClassLoader。如果我们要自定义自己的类加载器，很明显**需要继承 ClassLoader。**
- 如果我们不想打破双亲委派模型，就**重写 ClassLoader类中的findClass()** 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。
- 但是，如果想打破双亲委派模型则需要重写loadClass() 方法。

**自定义加载类（重写findClass）的意义**

可以以不同形式加载类，比如上例的本地文件中的类，网络二进制流获取需要的类。

可以对某些敏感的class文件进行加密，在findClass中进行解密。

还可以对生成的二进制代码做修改，给类添加一些信息。ASM——字节码增强技术。可以延申到AOP的实现。 

##### 什么时候需要打破双亲委派？

**原因在于双亲委派的局限性：**父级加载器无法加载子级类加载器路径中的类。

和SPI紧密相关，目的**JDK提供接口，供应商提供服务实现**。第三方实现只能放在classpath，但需要BootstrapClassLoader来加载，这时候就需要打破双亲委派机制。

以java.sql.Driver举例，JDBC在DriverManager中调用sql的Driver，DriverManager当前类的加载器是BootstrapClassLoader。BootstrapClassLoader去加载第三方类库的实现类，lib中找不到。**SPI Serviceloader通过从线程上下文（ThreadContext）获取application classloader**，借助这个classloader 可以拿到实现类的 Class。逻辑上打破了双亲委派。



## 对象

### Java对象的创建过程

**类加载检查、分配内存、初始化零值、设置对象头、执行init方法-构造方法**

#### 对象内存分配的两种方式

碰撞指针、空闲列表(标记-清除，内存不规整)

#### 内存分配并发问题

 为每一个线程预先在 Eden 区分配一块儿内存：TLAB。装不下的话：CAS+失败重试

### 对象头

**Mark Word，用于存储对象自身的运行时数据（哈希码、GC 分代年龄、锁类型、锁状态标志等等）**

**Klass Word，类型指针**，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。

如果对象是一个数组，那么对象头还需要有额外的空间用于存储数组的长度。

```sql
|-------------------------------------------------------|--------------------|
|                  Mark Word (32 bits)                  |       State        |
|-------------------------------------------------------|--------------------|
| identity_hashcode:25 | age:4 | biased_lock:1 | lock:2 |       Normal       |
|-------------------------------------------------------|--------------------|
|  thread:23 | epoch:2 | age:4 | biased_lock:1 | lock:2 |       Biased       |
|-------------------------------------------------------|--------------------|
|               ptr_to_lock_record:30          | lock:2 | Lightweight Locked |
|-------------------------------------------------------|--------------------|
|             ptr_to_heavyweight_monitor:30  | lock:2 | Heavyweight Locked |
|-------------------------------------------------------|--------------------|
|                                              | lock:2 |    Marked for GC   |
|-------------------------------------------------------|--------------------|
```

### 对象的访问定位

句柄：指向句柄。句柄中包含了对象实例数据与类型数据各自的具体地址信息，存放在堆中的句柄池中。

直接指针：指向堆中的对象。对象包括类型数据（对象头中的类型指针）。

在对象被移动时只会改变句柄中的实例数据指针，**而 reference 本身不需要修改。**使用直接指针访问方式最大的好处就是**速度快**，它节省了一次指针定位的时间开销。

### Java中对象的引用方式

级别由高到低依次为强引用、软引用、弱引用、虚引用。

**1. 强引用  对象的一般状态**

被强引用关联的对象不会被回收，宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。

使用 new 一个新对象的方式来创建强引用。

Object obj = new Object();

**2. 软引用 对象缓存**

**被软引用关联的对象**只有在**内存不够**的情况下才会被回收。可用来实现高速缓存，会大大降低OOM的概率。

使用 SoftReference 类来创建软引用。

```java
Object obj = new Object(); 
SoftReference<Object> sf = new SoftReference<Object>(obj);
obj = null;  // 使对象只被软引用关联  obj指向null 而之前地址的对象被软引用关联了
```

**3. 弱引用  对象缓存**

**被弱引用关联的对象一定会被回收**，也就是说它只能存活到下一次垃圾回收发生之前。

使用 WeakReference 类来创建弱引用。

```java
Object obj = new Object(); 
WeakReference<Object> wf = new WeakReference<Object>(obj); 
obj = null;
```

**4. 虚引用 哨兵**

为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。**跟踪对象被垃圾收集器回收的活动，起哨兵作用。**

又称为幽灵引用或者幻影引用，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。

必须和引用队列ReferenceQueue联合使用。GC在回收对象时，如果发现对象有虚引用，在回收之前，会首先把对象的虚引用加入到与之关联的队列中，**程序可以通过判断引用队列是否已经加入虚引用，来了解被引用的对象是否被GC回收。**因此起到了**哨兵作用。**

```java
Object obj = new Object(); 
ReferenceQueue queue = new ReferenceQueue<>(); 
PhantomReference<Object> pf = new PhantomReference<Object>(obj, quque); 
obj = null;
```

**虚引用与软引用和弱引用的一个区别在于：** 虚引用必须和引用队（ReferenceQueue）联合使用，构造方法之有传入队列的这一种。



## 垃圾回收

### 如何判断对象已无效、对象被判定为垃圾的标准

引用计数法：无法检测出循环引用

可达性分析算法更好。

#### 可以作为GC Root的对象

- 虚拟机栈(栈帧中的本地变量表)中引用的对象

- 本地方法栈(Native 方法)中引用的对象
- 方法区中常量引用的对象 final对象
- 方法区中类静态属性引用的对象 static对象
- 所有被同步锁持有的对象
- 活跃线程的引用对象
- JVM自身持有的对象，比如系统类加载器等
- 通过System Class Loader或者Boot Class Loader加载的class对象，通过自定义类加载器加载的class不一定是GC Root  

#### finalize方法的作用

**给对象创造最后一次逃脱死亡的机会。**在GC前被调用，有可能因此又可达了，取消GC。

要真正宣告一个对象死亡，至少要经历两次标记过程：可达性分析法中不可达的对象被第一次标记；并且进行一次筛选，如果对象覆盖了 finalize 方法，且finalize 方法没有被虚拟机调用过时，就会被放置在F-Queue中，并在稍后由虚拟机自动建立的低优先级的finalize线程去执行触发finalize方法（该线程运行优先级低，因此该方法随时可能被终止）。

### 方法区的回收

因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。

**主要是对常量池的回收和对类的卸载（主要）**

#### 如何判断一个常量是废弃常量

没有任何对象引用。注意区分`String str1 = "abcd";`和`String str2 = new String("abcd");`。

#### 如何判断一个类是无用的类

一个类可以回收的前提：

- 该类所有的实例都已经被回收，也就是 **Java 堆中不存在该类的任何实例。**
- 加载该类的 **ClassLoader 已经被回收。**
- 该类对应的 java.lang.Class对象没有在任何地方被引用，**无法在任何地方通过反射访问**该类的方法。

### 垃圾回收算法

#### 标记-清除算法 

先可达性标记，再遍历清除。标记和清除过程效率都不高；会产生大量不连续的内存碎片，导致无法给大对象分配内存。

#### 复制算法

解决了碎片化问题，顺序分配内存，简单高效。缺点是只使用了一半的内存。

**适用于对象存活率低的场景：用于年轻代，年轻代中的对象基本每次回收只有10%左右的存活，需要复制的对象很少。**

#### 标记-整理算法

解决了碎片化问题，不需要设置两块内存互换

**适用于对象存活率高的场景：用于老年代。**

#### 分代收集算法

堆内存分为老年代和年轻代，默认比例是2：1。**-XX:NewRatio**  

年轻代分为Eden区和两个Survivor区(from区和to区)，默认比例是8：1：1。 **-XX:SurvivorRatio**

##### Minor GC 和 Full GC

- Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。
- Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。

minorGC的时候，对象会在From区域和To区域中**复制**来复制去，如此交换15次-MaxTenuringThreshold，最终如果还存活，就存入老年代。

Survivor的存在意义，就是减少被送到老年代的对象，进而减少Full GC的发生，Survivor的预筛选保证，只有经历16次Minor GC还能在新生代中存活的对象，才会被送到老年代。



### 内存分配策略

**1. 对象优先在 Eden 分配**

**2. 大对象直接进入老年代**  -XX:PretenureSizeThreshold

避免在 Eden 和 Survivor 之间的大量内存复制。

**3. 长期存活的对象进入老年代**  -XX:MaxTenuringThreshold

**web应用中：线程池，静态变量引用的对象，spring容器里的bean，service，代码初始化的缓存对象，都一直存活，会放在老年代。**

**4. 动态对象年龄判定**

如果在 Survivor 中**相同年龄所有对象**大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。

**5. 空间分配担保**

在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间。如果不成立，虚拟机会查看 `HandlePromotionFailure` 的值是否允许担保失败，如果允许那么就会继续检查老年代**最大可用的连续空间是否大于历次晋升到老年代对象的平均大小**，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就直接进行一次 Full GC。

#### Full GC 的触发条件

**1. 调用 System.gc()**

只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。

**2. 老年代空间不足**

**3. 空间分配担保失败**

**4. JDK 1.7 及以前的永久代空间不足**

永久代中存放的为一些 Class 的信息、常量、静态变量等数据。当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满

**5. CMS GC的Concurrent Mode Failure和Promotion failed **

执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。

Promotion failed-minor GC时survivor区域放不下，只能放到老年代，此时老年代也放不下。



### 垃圾回收器

- **Serial既不能并发，也不能并行。**
- **Parallel和ParNew都可以并行，Parallel注重吞吐量。** 
- **CMS并发，采用标记清除。**
- **G1并发，标记整理，且有可预测的停顿。**
- **Serial和Parallel有Old，Serial、ParNew可以和CMS结合**(Parallel和G1没有用传统的GC代码框架)，G1新老都自己抗。
- [**未来还有ZGC**](https://tech.meituan.com/2020/08/06/new-zgc-practice-in-meituan.html)

CMS

- **初始标记**：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，**需要stop the world。**
- **并发标记**：并发进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。
- 并发预清理：查找执行并发标记阶段从年轻代晋升到老年代的对象。
- **重新标记**：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，**需要stop the world。**
- **并发清理：**不需要停顿。
- 重发重置：重置CMS的数据结构，准备下一次垃圾清理。

**缺点：**

**吞吐量低**：低停顿时间是以牺牲吞吐量为代价的，导致 **CPU 利用率不够高。**

**无法处理浮动垃圾，可能出现 Concurrent Mode Failure。**浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。

**标记 - 清除算法导致的空间碎片**，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。

**G1（Garbage-First）垃圾收集器**

G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。

**具备如下优点**

**并行与并发**：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。

**可预测的停顿**：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立**可预测的停顿时间模型**，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。

**分代收集**：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。

**空间整合**：与 CMS 的“标记-清理”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“**标记-复制**”算法实现的。

- 初始标记
- 并发标记
- 最终标记
- 筛选回收



## JVM性能调优



# [操作系统](docs/operating-system/操作系统基础.md)

操作系统本质上是一个运行在计算机上的**软件程序** ，用于**管理计算机硬件和软件资源。**

**操作系统存在屏蔽了硬件层的复杂性。** 操作系统就像是硬件使用的负责人，统筹着各种相关事项。

**操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理**。 内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性。



#### 基本特征

**1. 并发**

并发是指**宏观**上在一段时间内能同时运行多个程序，而并行则指**同一时刻**能运行多个指令。

**2. 共享**

共享是指系统中的资源可以被多个并发进程共同使用。

有两种共享方式：互斥共享和同时共享。互斥共享的资源称为临界资源，例如打印机等，在同一时刻只允许一个进程访问，需要用同步机制来实现互斥访问。

**3. 虚拟**

虚拟技术把一个物理实体转换为多个逻辑实体。

主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术。

多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。

虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。

**4. 异步**

异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。



系统调用：**凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，**都必须**通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。**

Linux 的系统调用主要有以下这些：

| Task     | Commands                    |
| -------- | --------------------------- |
| 进程控制 | fork(); exit(); wait();     |
| 进程通信 | pipe(); shmget(); mmap();   |
| 文件操作 | open(); read(); write();    |
| 设备操作 | ioctl(); read(); write();   |
| 信息维护 | getpid(); alarm(); sleep(); |
| 安全     | chmod(); umask(); chown();  |



**操作系统有哪些章节？字节跳动教育后端实习四面问到**

\1. 进程管理

进程控制（状态间转换）、进程同步、进程通信、死锁处理、处理机调度等。

\2. 内存管理

内存分配、地址映射、内存保护与共享、虚拟内存等。

\3. 文件管理

文件存储空间的管理、目录管理、文件读写管理和保护等。

\4. 设备管理

完成设备的请求或释放，方便用户使用各种设备，并提高设备的利用率。

主要包括缓冲管理、设备分配、设备处理、虛拟设备等。



#### 中断分类

中断是指计算机运行过程中，出现某些**意外情况**需主机干预时，机器能**自动停止正在运行的程序**并转入处理新情况的程序，处理完毕后又返回原被暂停的程序继续运行。

从本质上来讲，中断是一种电信号，当设备有某种事件发生时，它就会产生中断，通过总线把电信号发送给中断控制器。

\1. 异常

又称同步中断，是在指令执行时由**CPU主动产生**的，受到CPU控制，其执行点是可控的。异常可分为故障（fault）、陷阱（trap）和终止（abort）三类。如非法操作码、地址越界、算术溢出等。

其余中断是CPU被动接收到的，称为异步中断/外中断。

\2. 外中断

又称异步中断。由 CPU 执行指令以外的事件引起，由外设发出的电信号引起，其发生时间不可预测，如 **I/O 完成中断**，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有**时钟中断、控制台中断**等。

\3. 陷入

又称软中断。在用户程序中使用系统调用，模式切换时，需要软中断。

为了保护系统数据不受非法篡改，需要审核陷入内核的这种访问是否合法，这种审核也叫**软中断**，如果非法，就会中断访问。黑客攻入就是巧妙得绕过了软中断。需要不断打补丁，关掉漏洞。



### cache和buffer

**Buffer**（缓冲区）是系统两端处理**速度平衡**（从长时间尺度上看）时使用的。它的引入是为了减小短期内突发I/O的影响，起到**流量整形**的作用。比如生产者——消费者问题，他们产生和消耗资源的速度大体接近，加一个buffer可以抵消掉资源刚产生/消耗时的突然变化。比如从网上下电影，你不能下一点点数据就写一下硬盘，而是积攒一定量的数据以后一整块一起写，不然硬盘都要被你玩坏了。
**Cache**（缓存）则是系统两端处理**速度不匹配**时的一种**折衷策略**。因为CPU和memory之间的速度差异越来越大，所以人们充分利用数据的局部性（locality）特征，通过使用存储系统分级（memory hierarchy）的策略来减小这种差异带来的影响。

假定以后存储器访问变得跟CPU做计算一样快，cache就可以消失，但是buffer依然存在。比如从网络上下载东西，瞬时速率可能会有较大变化，但从长期来看却是稳定的，这样就能通过引入一个buffer使得OS接收数据的速率更稳定，进一步减少对磁盘的伤害。

**TLB（Translation Lookaside Buffer，翻译后备缓冲器）名字起错了，其实它是一个cache。**

cache是自己写了准备自己读的，buffer是自己写了准备别人读的。

Cache 是有 source of truth 的，里面的数据如果没有了可以去 source of truth 重新获取，最多就是浪费一下性能而已。Buffer 不一定存在 source of truth，往里面写的东西写不下了或者丢了就永久丢了。



## 进程

### 进程与线程的区别

**进程是资源分配的最小单位，线程是CPU调度的最小单位。**

- **拥有资源：进程是资源分配的最小单位；线程属于某个进程，共享其资源。**

- - 进程拥有完整的虚拟内存地址空间，不同进程有不同虚拟地址空间，同一进程的不同线程共享同一地址空间。

- **是否独立：进程可以看作独立应用（独立的调度、管理、资源分配），线程不能看成独立应用，必须依存于某个应用程序。**线程是进程划分成的更小的运行单位。线程执行开销小，但不利于资源的管理和保护

- - **进程有独立的地址空间，相互不影响，线程只是进程的不同执行路径。**
  - 一个进程崩溃后，在保护模式下不会对其他进程产生影响；而一个线程崩溃，所在的进程都会崩溃。因此多进程的程序要比多线程的程序健壮。

- **切换开销：进程切换比线程切换开销大。**

- - 由于**创建或撤销**进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。
  - 在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。

- **通信：**线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助IPC。



#### 协程

**协程routine，**是一种比线程更加轻量级的存在。**一个线程可以有多个协程，协程只是线程内的内存模型。**协程不是被操作系统内核所管理，而**完全是由程序所控制（也就是在用户态执行）**。不同于函数只能顺序执行完一个函数再执行下一个，协程在子程序内部是可中断的，然后转而执行别的子程序，在适当的时候再返回来接着执行。

**协程的特点在于是一个线程执行，那和多线程比，协程有何优势？**

极高的执行效率：**因为子程序切换不是线程切换，而是由程序自身控制**，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显；**协程的切换开销更小，不需要cpu的切换，只需要内存的切换开销。**

**不需要多线程的锁机制：串行执行。**因为只有一个线程，也不存在同时写变量冲突，在协程中控制**共享资源不加锁**，只需要判断状态就好了，所以执行效率比多线程高很多。

**Go 语言支持并发，我们只需要通过 go 关键字来开启 goroutine 即可。**

goroutine 是轻量级线程，goroutine 的调度是由 Golang 运行时进行管理的。

**lua脚本就是基于协程机制完成nginx开发，很少直接用c，c++了现在。**



#### 进程的状态

- **创建状态(new)** ：进程正在被创建，尚未到就绪状态。
- **就绪状态(ready)** ：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。
- **运行状态(running)** ：进程正在处理器上上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。
- **阻塞状态(block/waiting)** ：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。
- **结束状态(terminated)** ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。
- **挂起(Suspend)** **：**在内存资源不足的情况下，有的进程被暂时调离出内存，当条件允许的时候，会被操作系统再次调回内存。



### 进程的通信

**2021春招暑期实习腾讯二面问到，一般会怎样进行选择？哪种比较好？你为什么说共享内存是最快的？比命名管道快在哪里？**

进程通信是一种手段，而进程同步是一种目的（对资源使用的时候进程之间的协调，控制多个进程按一定顺序执行；）。**也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。**

每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为**进程间通信（IPC，InterProcess Communication）**

**1. 匿名管道(Pipes)** 

匿名管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。

\#include <unistd.h> int pipe(int fd[2]);

- 以内存文件方式存在。匿名管道由于没有名字，只能用于亲缘关系（在父子进程/兄弟进程）的进程间通信。
- 只支持半双工通信（单向交替传输）
- **阻塞问题：**如果当前进程向无名管道的一端写数据，必须确定另一端有某一进程。

**2.命名管道(Names Pipes)** 

- 以磁盘文件方式存在，可以实现本机任意两个进程通信
- **严格遵循先进先出(first in first out)。**
- **命名管道阻塞问题：**以读方式打开某管道，在此之前必须一个进程以写方式打开管道，否则阻塞。此外，可以以读写（O_RDWR）模式打开有名管道，即当前进程读，当前进程写，不会阻塞。

**3. 消息队列(Message Queuing)** 

- 消息队列允许一个或多个进程向它写入与读取消息。
- 存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。
- 克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺。

**相比于命名管道，消息队列具有以下优点：**

- 消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；
- 避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；
- 读进程可以实现消息的随机查询，可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。

**4. 信号(Signal)** ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；

**5. 信号量(Semaphores)** ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。

**6. 共享内存(Shared memory)** ：多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。==**因为数据不需要在进程之间复制，所以这是最快最有用的一种 IPC。**==

- 使得多个进程可以可以直接读写同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。
- 为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以**直接读写这一块内存**而不需要进行数据的拷贝，从而大大提高效率。
- 由于多个进程共享一段内存，因此需要**依靠某种同步机制**（如信号量）来达到进程间的同步及互斥。

**7. 套接字(Sockets)** : 不同机器间的进程的网络通信。



#### 线程间的同步的方式

**同步：控制多个进程/线程按一定顺序执行；**

线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。操作系统一般有下面三种线程同步的方式：

1. **互斥量(Mutex)**：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。
2. **信号量(Semphares)** ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量
3. **事件(Event)** :Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操



### 进程的调度算法

**调度的评价标准**

**（1） CPU利用率**

**（2） 系统吞吐量**

**（3） 周转时间**

**（4） 等待时间**

**（5） 响应时间**

**1. 批处理系统**

批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。

**1.1 先来先服务 first-come first-serverd（FCFS）**

非抢占式的调度算法，按照请求的顺序进行调度。直到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。

优缺点：有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。

**1.2 短作业优先 shortest job first（SJF）**

非抢占式的调度算法，按估计运行时间最短的顺序进行调度。直到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。

优缺点：**仅照顾了短进程而忽略了长进程** 。长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。

**1.3 最短剩余时间优先 shortest remaining time next（SRTN）**

最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。

**2. 交互式系统**

交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。

**2.1 时间片轮转调度算法** : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin)调度。将所有就绪进程按 FCFS 的原则排成一个队列，每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。

时间片轮转算法的效率和时间片的大小有很大关系（Trade-Off）：

- 因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。
- 而如果时间片过长，那么实时性就不能得到保证。

**2.2 优先级调度** ： 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以**根据内存要求，时间要求或任何其他资源要求**来确定优先级。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。

**2.3 多级反馈队列调度算法** ：可以将这种调度算法看成是**时间片轮转调度算法和优先级调度算法的结合。**多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。因而它是目前**被公认的一种较好的进程调度算法**，UNIX 操作系统采取的便是这种调度算法。

比如：一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。

**每个队列优先权也不同，最上面的优先权最高。**因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。

**3. 实时系统**

**实时系统要求一个请求在一个确定时间内得到响应。**

**分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。**

**3.1  EDF算法（Earliest DeadLine First）**

根据任务的最早截至时间来确定任务的优先级，即任务的开始截止时间/结束截止时间越早，其优先级越高。在实现该算法时，要求系统中保持一个实时任务就绪队列，该队列按各任务的截止时间的早晚排序。

对于周期截止时间的任务，可以预测，则采用抢占式算法。

对于非周期性的具有截止时间的任务，不可预测，一般采用允许CPU空闲的EDF调度算法，指优先调度最早截止时间的任务，并将它执行完毕才调度下一个任务(非抢占方式)。

**3.2 速度单调调度算法**

**通俗讲，就是速度(频率)越高，优先级越高**

基于周期给优先级**，周期越短，频率越高，优先级越高**



### 死锁

**产生死锁的条件 前三点是必要条件，第四点是充分条件**

**• Mutual exclusion(互斥)** 资源互斥使用，一次只允许一个进程使用

**• Hold-and-wait(保持并等待)**  申请到了资源，占用这个资源，并申请其他资源

**• No preemption(不剥夺)**  申请到资源，无法剥夺

**• Circular wait(环路等待)**  前三个条件的可能结果，出现环路等待了，一定会死锁

字节一面问到实际生活的死锁例子，比如说卖苹果，买家要先拿到东西再付钱，卖家要先拿到钱再给东西。

怎么解决，tryacquire一段时间，获取不到就不要了。

**预防死锁**

**间接方法，禁止前3个条件之一的发生：**

**1.禁止“保持并等待”条件**：要求进程**一次性地申请其所需的全部资源**。若系统中没有足够的资源可分配给它，则进程阻塞。 

**效率和资源利用率很低：**

必须知道进程整个生存区(从产生到结束)需要用到哪些资源。还必须全拿到

要拿到全部资源，有可能最后才用一下，也有可能if else 执行过程中只用一小部分，但需要全部申请占用。

**2.禁止“不剥夺”条件**

若一个进程申请的资源被另一个进程占有，OS可以剥夺低优先权进程的资源分配给高

优先权的进程（要求此类可剥夺资源的状态易于保存和恢复，否则不能剥夺，比如正在打印，结果剥夺了，前面打印都无效了）

**直接方法**

**禁止“环路等待”条件：**将系统的所有资源按类型不同进行**线性排队**，并赋予不同的序号。进程对某类资源的申请只能按照序号递增的方式进行。  低效

以上间接或直接的预防死锁的方法都依靠较强的限制条件实现，性能会受很大的影响

**避免死锁——银行家算法——实际上是避免系统进入不安全状态，时刻都能找到一个安全序列**

**其他进程的资源分配都会影响本进程，如果资源申请可能使系统处于不安全状态，进程会阻塞等待。因此进程在系统中的运行是不可预测的，异步运行，走走停停。**

•避免死锁的关键在于为进程分配资源之前，**首先通过计算，判断此次分配是否会导致死锁**，只有不会导致死锁的分配才可实行。

要求知道所有的进程整个运行期间用到哪些资源以及系统能提供哪些资源。



## 内存管理

### 虚拟内存

**简单和虚拟的区别：进程是否需要在执行前把数据全部一次性装入内存**

虚拟内存的目的是为了让**物理内存扩充成更大的逻辑内存**，通过虚拟内存可以让程序可以把内存扩展到硬盘空间。从而让程序获得更多的可用内存。

**什么是虚拟内存(Virtual Memory)?**

**虚拟内存** 使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片（页），还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。**当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。**

**特点**

1. 一定容量的内存和外存：在载入程序的时候，只需要将程序的一部分装入内存，而将其他部分留在外存，然后程序就可以执行了；
2. **缺页中断**：如果**需执行的指令或访问的数据尚未在内存**（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段**调入到内存**，然后继续执行程序；
3. **虚拟地址空间** ：逻辑地址到物理地址的变换。

好处：能装入更多更大的进程，能执行很大很大很大的进程。更多进程的好处，CPU调度ready的概率高，CPU的利用率提高。极端例子：如果只有一个进程装满了内存，这个进程blocked，CPU也停下来了。



**虚拟存储的理论支撑：Principle of Locality (局部性原理)**

时间局部性：cache也叫buffer（缓冲区）中装最近用过的代码，数据，TLB，将来也可能用。

空间局部性：空间上执行了一块代码，在空间上还可能用到相邻的代码。装的时候装第一个cluster的时候，应该把相邻的也装进去。



### 虚拟地址-物理地址 如何寻址

现代处理器使用的是一种称为 **虚拟寻址(Virtual Addressing)** 的寻址方式。**使用虚拟寻址，CPU 需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存。** 

#### 为什么要有虚拟地址空间呢？

离散变为相邻，更大的程序，更安全。

- 程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区。
- 程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。当物理内存的供应量变小时，内存管理器会将物理内存页（通常大小为 4 KB）保存到磁盘文件。数据或代码页会根据需要在物理内存与磁盘之间移动。
- 不同进程使用的虚拟地址彼此隔离。一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。没有虚拟地址的时候用户程序可以访问任意内存，寻址内存的每个字节，这样就很容易（有意或者无意）破坏操作系统，造成操作系统崩溃。



**逻辑(虚拟)地址和物理地址转换**

我们编程一般只有可能和逻辑地址打交道，比如在 C 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定。逻辑地址是一个相对地址，相对于某个点的第几条语句物理地址指的是真实物理内存中地址，更具体一点来说就是内存地址寄存器中的地址。**物理地址是内存单元真正的地址。**

逻辑地址必须转换成物理地址，处理器才能执行



#### 寻址的过程

**1. 根据进程的逻辑地址及页大小求出页号和页内偏移**

**2. **寄存器比内存快很多，当前正在执行的进程，才会把**页表起始地址**放到**页表寄存器**。根据页表起始地址，找到**页表。**

**3. **从页表中根据**页号和页框**的对应关系读出进程的页号所在的**页框地址（实际地址）**，再用**页框号+相对地址（偏移量）==物理地址**  高字节是页框号，低字节是偏移量  直接相加即可



#### 快表 TLB

为了解决虚拟地址到物理地址的转换速度，操作系统在 **页表方案** 基础之上引入了 **快表** 来**加速虚拟地址到物理地址的转换。**我们可以把块表理解为一种特殊的**高速缓冲存储器（Cache）**，其中的内容是页表的一部分或者全部内容。

**TLB 页号找页框号  页框号+偏移量**  

使用快表之后的地址转换流程是这样的：

1. 根据虚拟地址中的页号查快表；
2. **如果该页在快表中，不需要访问页表，直接从快表中读取相应的物理地址；**
3. 如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中；
4. 当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。

**多级页表**

引入多级页表的主要目的是为了避免把全部页表一直放在内存中占用过多空间，特别是那些根本就不需要的页表就不需要保留在内存中。多级页表属于时间换空间的典型场景，具体可以查看下面这篇文章

- [多级页表如何节约内存](https://www.polarxiong.com/archives/多级页表如何节约内存.html)



### 内存管理机制

*操作系统的内存管理机制了解吗？内存管理有哪几种方式?*

**存储空间是否连续，连续：分区， 离散：分页和分段**  

1. **块式管理** ： 远古时代的计算机操系统的内存管理方式。将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片。
2. **页式管理** ：把主存分为大小相等且固定的一页一页的形式，页较小，相对相比于块式管理的划分力度更大，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。
3. **段式管理** ： 页式管理虽然提高了内存利用率，但是页式管理其中的页实际并无任何实际意义。 段式管理把主存分为一段段的，每一段的空间又要比一页的空间小很多 。但是，最重要的是段是有实际意义的，每个段定义了一组逻辑信息，例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。
4. **段页式管理机制** 。程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。**<font color=red>这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。</font>**

#### 分区

**缺点**

- 存在内零头（空着但其他进程不能访问）；
- 尺寸固定，系统无法运行大程序
- 分区数目固定,使活动进程的数目受限

动态分区

- 存在外零头   每个都比较小，容纳不下一个进程所需，但是加起来超过

- 必须依靠紧凑技术来整理碎片空间



#### 分页

把内存空间划分成若干页，可以占很多页面，记下来页在哪里，**物理上是离散的，逻辑上串成连续。**

**分页技术是目前内存空间利用率最大的一种技术。**不存在外零头，存在内零头(进程的最后一页的余数，如上例478)，平均是页大小/2。

把内存空间划分若干大小相同的**页框（物理上）**。硬件决定划分，买机器的时候已经确定。把进程也划分成相同大小的页

页式管理通过页表对应逻辑地址和物理地址，操作系统为每个进程维护一个页表，**页号对应页框**。

##### 页多大比较好？

太小不行，太大也不行

- i/o喜欢大页面      
- 小页面需要大页表的管理（虚拟，多级）       
- 小页面内零头小
- 页面缺页率的关系是抛物线，太大缺页率显著上升。

##### 面试问题，在你眼中页是什么？

为了更好的管理内存，操作系统**将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。**这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。



#### 分段

分成若干分区，Pi可以**由多个模块构成，一个模块占一块空间**

与动态分区的缺点相同，存在外零头，需要紧凑，增加了系统开销。因此一般用段页式，逻辑地址是段号+页号+偏移量



##### 分页机制和分段机制的共同点和区别

1. **共同点** ：

- - 分页机制和分段机制都是为了提高内存利用率，较少内存碎片。
  - 页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。

1. **区别** ：

- - 页的大小是固定的，由操作系统决定；而段的大小不固定，取决于我们当前运行的程序。
  - 目的不同：分页仅仅是为了满足操作系统内存管理的需求，主要用于提高内存的利用率，消除外零头，抑制内零头；实现虚拟内存，从而获得更大的地址空间，而段是逻辑信息的单位，在程序中可以体现为代码段（子函数），数据段，有利于**模块化**程序设计。
  - 对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。
  - 地址空间的维度：对于用户来说，分页是一维地址空间，分段是二维的（第几段的第几行）。例如分页例题1502，1502/页的大小可以算出页号和页内偏移量



####  页面置换算法

👨‍💻**面试官** ：虚拟内存管理很重要的一个概念就是页面置换算法。那你说一下 **页面置换算法的作用?常见的页面置换算法有哪些?**

地址映射过程中，若在页面中发现所要访问的页面不在内存中，则发生缺页中断 。

**缺页中断** 就是要访问的**页**不在主存，需要操作系统将其调入主存后再进行访问。 在这个时候，被内存映射的文件实际上成了一个分页交换文件。

**==当发生缺页中断时，如果当前内存中并没有空闲的页面==**，操作系统就必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。用来选择淘汰哪一页的规则叫做页面置换算法，我们可以把页面置换算法看成是淘汰页面的规则。

- **OPT 页面置换算法（最佳页面置换算法）** ：最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。一般作为衡量其他置换算法的方法。

- **FIFO（First In First Out） 页面置换算法（先进先出页面置换算法）** : 总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。

  - Belady现象：异常现象，即增加为单个进程分配的页框数，缺页率反而上升。

- **LRU （Least Currently Used）页面置换算法（最近最久未使用页面置换算法）** ：LRU算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。

- **LFU （Least Frequently Used）页面置换算法（最少使用页面置换算法）** :  该置换算法选择在之前时期使用最少的页面作为淘汰页。

- **时钟置换算法：LRU的简化近似**

  **页面装入和访问的时候置1。**

  **需要置换的时候，扫描，遇到的第一个是零的页面置换掉**

  也就是说：**上次访问到这次访问之间，**用过的话是1，没有的话是0。没有用过的随便挑一个。不考虑频率，只考虑上次访问到这次访问之间的最近。

**==要会写LRU和LFU==**

## I/O管理、磁盘管理

#### 磁盘结构

- 盘面（Platter）：一个磁盘有多个盘面；
- 磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道；
- 扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理储存单位，目前主要有 512 bytes 与 4 K 两种大小；
- 磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）；
- 制动手臂（Actuator arm）：用于在磁道之间移动磁头；
- 主轴（Spindle）：使整个盘面转动。

### 磁盘调度算法

来自不同进程的磁盘I/O请求会构成一个随机分布的请求队列。 到底先读哪一个呢？

读写一个磁盘块的时间的影响因素有：

- 旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）
- 寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）
- 实际的数据传输时间

其中，寻道时间最长，因此**磁盘调度的主要目标是使磁盘的平均寻道时间最短。**

1. 先来先服务

FCFS, First Come First Served

按照磁盘请求的顺序进行调度。

优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。

2. 最短寻道时间优先

SSTF, Shortest Seek Time First

优先调度与当前磁头所在磁道距离最近的磁道。

虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两端的磁道请求更容易出现饥饿现象。

3. 电梯算法

SCAN

电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。

电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。

因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。



# [MySQL](docs/database/MySQL.md)

## 索引

**索引是一种用于快速查询和检索数据的数据结构。通常在涉及到文件的管理的应用都会有索引，比如数据库，操作系统文件管理，对象存储。**常见的索引结构有: B树， B+树和Hash。



## 事务

### 事务的四大特性

**1. 原子性（Atomicity）**

事务被视为不可分割的最小单元，**事务的所有操作要么全部提交成功，要么全部失败回滚。**

**回滚可以用回滚日志（Undo Log）来实现，**回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。

**2. 一致性（Consistency）**

**所有事务对同一个数据的读取结果都是相同的。**

**3. 隔离性（Isolation）**

**一个事务所做的修改在最终提交以前，对其它事务是不可见的。**

**4. 持久性（Durability）**

一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。

**系统发生奔溃可以用重做日志（Redo Log）进行恢复**，从而实现持久性。与回滚日志记录数据的逻辑修改不同，重做日志记录的是数据页的物理修改。



## 存储引擎

```sql
#查看MySQL提供的所有存储引擎 
show engines;

#我们也可以通过下面的命令查看默认的存储引擎。
show variables like '%storage_engine%';

#查看表的存储引擎，表的Engines项为表的引擎
show table status like "table_name" ;
```

### MyISAM和InnoDB的区别

- **事务：InnoDB 是事务型的，支持提交、回滚和紧急恢复功能来保护数据安全。**

- **并发：MyISAM 只支持表级锁，并发性差，而 InnoDB 还支持行级锁。**

- **索引：InnoDB 支持外键(B+树存主键的值)**  

- **数据存储：InnoDB是聚簇索引，MyISAM不是。**辅助索引也不同----InnoDB的辅助索引data域存储相应记录主键的值而不是地址。

- **是否支持MVCC：仅 InnoDB 支持。**应对高并发事务, MVCC比单纯的加锁更高效；MVCC只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作；MVCC可以使用乐观(optimistic)锁和悲观(pessimistic)锁来实现；各数据库中MVCC实现并不统一。

- **备份：InnoDB 支持在线热备份。** 热备份是系统处于正常运转状态下的备份，MySQL的其他存储引擎不支持热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。

- **崩溃恢复：宕机后，InnoDB崩溃修复能力更强，而且恢复的速度也更快。**

- 其它特性：MyISAM提供全文索引、压缩、空间函数。

  

MySQL高性能》上面有一句话这样写到:

> 不要轻易相信“MyISAM比InnoDB快”之类的经验之谈，这个结论往往不是绝对的。在很多我们已知场景中，InnoDB的速度都可以让MyISAM望尘莫及，尤其是用到了聚簇索引，或者需要访问的数据都可以放入内存的应用。

一般情况下我们选择 InnoDB 都是没有问题的，但是某些情况下你并不在乎可扩展能力和并发能力，也不需要事务支持，也不在乎崩溃后的安全恢复问题的话，选择MyISAM也是一个不错的选择。但是一般情况下，我们都是需要考虑到这些问题的。



### 如何选取存储引擎

**MyISAM的适合场景**

- 频繁执行全表count语句。select count(*) from table 
  - MyISAM用一个变量保存了表的行数。InnoDB需要扫描统计

- **对数据进行增删改的频率不高，查询非常频繁的时候**
  - 增删改涉及锁表操作，每次都是表锁，并发性能很差

- 没有事务

**InnoDB适合的场景**

- 数据增删改查都频繁

- 可靠性要求比较高，要求支持事务的系统



如果只是临时存放数据，数据量不大，并且不需要较高的数据安全性，可以选择将数据保存在内存中的Memory引擎，MySQL中使用该引擎作为临时表，存放查询的中间结果

如果只有INSERT和SELECT操作，可以选择Archive，Archive支持高并发的插入操作，但是本身不是事务安全的。Archive非常适合存储归档数据，如**记录日志信息可以使用Archive。**



《MySQL高性能》上面有一句话这样写到：

不要轻易相信“MyISAM比InnoDB快”之类的经验之谈，这个结论往往不是绝对的。在很多我们已知场景中，InnoDB的速度都可以让MyISAM望尘莫及，尤其是用到了聚簇索引，或者需要访问的数据都可以放入内存的应用。

一般情况下我们选择 InnoDB 都是没有问题的，但是某些情况下你并不在乎可扩展能力和并发能力，也不需要事务支持，也不在乎崩溃后的安全恢复问题的话，选择MyISAM也是一个不错的选择。但是一般情况下，我们都是需要考虑到这些问题的。



### 索引使用规范

**1. 限制每张表上的索引数量,建议单张表索引不超过 5 个**

**2 禁止给表中的每一列都建立单独的索引**

**3. 每个 Innodb 表必须有个主键**

**4. 常见索引列建议**

- 出现在 SELECT、UPDATE、DELETE 语句的 WHERE 从句中的列
- 包含在 ORDER BY、GROUP BY、DISTINCT 中的字段
- 并不要将符合 1 和 2 中的字段的列都建立一个索引， 通常将 1、2 中的字段建立联合索引效果更好
- 多表 join 的关联列

**5.如何选择索引列的顺序**

**区分度最高，使用最频繁，字段长度最小的往左边放。**

**6. 避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）**

**7. 对于频繁的查询优先考虑使用覆盖索引**

覆盖索引：就是包含了所有查询字段 (where,select,ordery by,group by 包含的字段) 的索引

**覆盖索引的好处：**

- **避免 Innodb 表进行索引的二次查询**
- **可以把随机 IO 变成顺序 IO 加快查询效率:** 覆盖索引是按键值的顺序存储的。

**8.尽量避免使用外键约束**

- 不建议使用外键约束（foreign key），但一定要在表与表之间的关联键上建立索引
- 外键可用于保证数据的参照完整性，但建议在业务端实现
- 外键会影响父表和子表的写操作从而降低性能

**避免使用子查询，可以把子查询优化为 join 操作**

通常子查询在 in 子句中，且子查询中为简单 SQL(不包含 union、group by、order by、limit 从句) 时,才可以把子查询转化为关联查询进行优化。

**子查询性能差的原因：**

子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响。特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大。

由于子查询会产生大量的临时表也没有索引，所以会消耗过多的 CPU 和 IO 资源，产生大量的慢查询。

**WHERE 从句中禁止对列进行函数转换和计算**

对列进行函数转换或计算时会导致无法使用索引



### 数据库基本设计规范

**1. 所有表必须使用 Innodb 存储引擎**

没有特殊要求（即 Innodb 无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用 Innodb 存储引擎（MySQL5.5 之前默认使用 Myisam，5.6 以后默认的为 Innodb）。

Innodb 支持事务，支持行级锁，更好的恢复性，高并发下性能更好。

**2. 尽量控制单表数据量的大小,建议控制在 500 万以内。**

500 万并不是 MySQL 数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题。

可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小

**3.尽量做到冷热数据分离,减小表的宽度**

MySQL 限制每个表最多存储 4096 列，并且每一行数据的大小不能超过 65535 字节。

**减少磁盘 IO,保证热数据的内存缓存命中率**（表越宽，把表装载进内存缓冲池时所占用的内存也就越大,也会消耗更多的 IO）；

更有效的利用缓存，避免读入无用的冷数据；

经常一起使用的列放到一个表中（避免更多的关联操作）。

**4.谨慎使用 MySQL 分区表**

分区表在物理上表现为多个文件，在逻辑上表现为一个表；谨慎选择分区键，跨分区查询效率可能更低；

建议采用物理分表的方式管理大数据。

- 数据库和表的字符集统一使用 UTF8
- 所有表和字段都需要添加注释
- 禁止在表中建立预留字段
- 禁止在数据库中存储图片,文件等大的二进制数据
- 禁止在线上做数据库压力测试
- 禁止从开发环境,测试环境直接连接生产环境数据库



### 字段设计规范

**1.优先选择符合存储需要的最小的数据类型**

**2.尽可能把所有列定义为 NOT NULL**

**3.同财务相关的金额类数据必须使用 decimal 类型 --价格**

- 非精准浮点：float,double
- 精准浮点：decimal

**使用 TIMESTAMP(4 个字节) 或 DATETIME 类型 (8 个字节) 存储时间**

**避免使用 TEXT,BLOB 数据类型，最常见的 TEXT 类型可以存储 64k 的数据**

**避免使用 ENUM 类型**



## 优化

### 慢查询优化

**如何定位并优化慢查询SQL**

1. 根据慢查询日志定位慢查询SQL
2. 使用explain等工具分析SQL
3. 修改SQL让SQL尽量走索引

#### explain

table | type | possible_keys | key |key_len | ref | rows | Extra



# [Redis](docs/database/Redis.md)

### 分布式锁

开源框架Redisson用Redis实现了分布式锁。




# [计算机网络](docs/network/network-basic.md)

==**必会问题**==

- [ ] **简述HTTP的5个常用Method及其含义，GET和POST的区别**
- [ ] **简述以及5个常用Status Code及其含义**
- [ ] **HTTP与HTTPS的区别是什么，简述一下HTTPS的实现原理**
- [ ] **HTTP1.1/2.0新特性**



## 基础知识

总时延 = 排队时延 + 处理时延 + 传输时延 + 传播时延

根据信息在传输线上的传送方向，分为以下三种通信方式：

- 单工通信：单向传输
- 半双工通信：双向交替传输
- 全双工通信：双向同时传输



**五层协议** **报文-数据段-数据包-数据帧-数据位**

- **应用层** ：为特定应用程序提供数据传输服务。
- **传输层** ：为进程提供通用数据传输服务。
- **网络层** ：为主机提供数据传输服务。
- **数据链路层** ：为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。
- **物理层** ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。尽可能屏蔽传输媒体和通信手段的差异。

**OSI比五层协议多两层**

其中表示层和会话层用途如下：

- **表示层** ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。
- **会话层** ：建立及管理会话。

**TCP/IP只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。**



### 链路层

目前数据链路层广泛使用了**循环冗余检验（CRC）**来检查比特差错。--左移，求余

**信道分类**

广播信道：一对多通信，一个节点发送的数据能够被广播信道上所有的节点接收到。所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。

主要有两种控制方法进行协调，一个是使用信道复用技术，一是使用 **CSMA/CD** 协议。

点对点信道：一对一通信。因为不会发生碰撞，因此也比较简单，使用 PPP 协议进行控制。



## 网络层

### ICMP

腾讯云暑期实习3面问到。

**Ping的原理是什么？Traceroute的原理是什么？最大的TTL设置为多少？**





## 传输层

### TCP与UDP的区别

- TCP面向连接，UDP无连接。
- TCP 是一对一的两点服务，UDP 支持一对一、一对多、多对多的交互通信。
- TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按需到达。UDP 尽最大努力交付，不保证可靠交付数据。
- TCP 有拥塞控制和流量控制机制，UDP 没有
- TCP面向字节流，UDP是报文段
- TCP传输所需资源多，传输慢；UDP传输所需资源少，传输快。
- TCP首部长度可变（20-60字节） UDP首部固定8字节

### TCP与UDP应用场景

由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：

- HTTP/HTTPS SSH
- FTP文件传输、POP3 SMTP 发送和接收邮件、TELNET远程登录等场景。

由于 UDP 面向无连接，它可以随时发送数据，再加上UDP本身的处理既简单又高效，因此经常用于：

- 包总量较少的通信，如 DNS 、SNMP 等
- 即时通信：视频、音频等多媒体通信
- **DHCP**（Dynamic Host Configuration Protocol，动态主机配置协议），动态配置IP地址。



#### 如何理解TCP面向字节流，UDP面向报文段？

**问题的关键在于TCP是有缓冲区**，作为对比，UDP面向报文段是没有缓冲区的。

TCP是面向字节流的，它把上面应用层交下来的数据看成无结构的字节流来发送，可以想象成流水形式的，发送方TCP会将数据放入**“蓄水池”（缓冲区）**，等到可以发送的时候就发送，不能发送就等着，跟应用层写下来的报文长度没有任何关系，TCP会根据当前网络的拥塞状态来确定每个报文段的大小。并且在TCP建立连接前两次握手的SYN报文中选项字段的MSS值，通信双方商定通信的最大报文长度。如果应用层交付下来的数据过大，就会对数据分段，然后发送。

UDP是面向报文的，发送方的UDP对应用层交下来的报文，无论多长，既不合并，也不拆分，只是在其上面加上首部后就交给了下面的网络层，也就是说无论应用层交给UDP多长的报文，它统统发送，一次发送一个。而对接收方，接到后直接去除首部，交给上面的应用层就完成任务了。因此，它需要应用层控制报文的大小。UDP发送端调用了几次write，接收端必须用相同次数的read读完。



#### 既然 IP 层会分片，为什么 TCP 层还需要 MSS 呢？

**MSS主要为了TCP的超时重传。**如果只有IP层的分片，一片丢失之后，整个IP报文的所有分片都得重传。为了达到最佳的传输效能 TCP 协议在**建立连接的时候通常要协商双方的 MSS 值**，当 TCP 层发现数据超过 MSS 时，则就先会进行分段，如果一段丢失，只会超时重传丢失的那一段。



### TCP、UDP头部格式

**TCP首部20-60字节** 

**固定20字节：源端口目的端口(4) 序列号(4) 确认号(4)  窗口(2)  校验和(2) 首部长度(4b) 标记位(6b) 紧急指针(2) **

**可变： 选项   填充**

**控制位：**

- ACK：确认序号有效。TCP 规定除了最初建立连接时的 SYN 包之外该位必须设置为 1 。
- **RST：TCP 连接中出现异常必须强制断开连接。记忆：RESET**
- SYN：发起一个新连接。
- FIN：释放一个连接。
- **PSH：接收方应该尽快将这个报文交给应用层。**
- **URG：紧急指针（urgent pointer）有效。**

**2字节的紧急指针什么用？**

**紧急指针指出的是紧急数据在报文段中结束的位置**

有时一些应用程序在某些紧急情况下（如在某些连接中进行强制中断）要求在接收方在没有处理完数据之前就能够发送一些紧急数据，这就使得发送方将CODE字段的URG置为1，即紧急指针字段有效，这样可以不必考虑你发送的紧急数据在数据流中的位置，也就是相当于**优先级最高**。



UDP 协议真的非常简单，头部只有 8 个字节，UDP 的头部格式如下：

- 目标(2)和源端口(2)：主要是告诉 UDP 协议从哪个进程来，应该把报文发给哪个进程。
- 包长度(2)：该字段保存了 UDP 首部的长度跟数据的长度之和。
- 校验和(2)：校验和是为了提供可靠的 UDP 首部和数据而设计。

**为什么 UDP 头部没有「首部长度」字段，而 TCP 头部有「首部长度」字段呢？**

TCP 有**可变长**的「选项」字段，而 UDP 头部长度则是**不会变化**的，无需多一个字段去记录 UDP 的首部长度。



### TCP协议如何保证可靠传输 ⭐

1. **校验和**：发送方在发送数据之前计算检验和，并进行校验和的填充。接收方，收到数据后，对数据以同样的方式进行计算，求出校验和，与发送方的进行比对
2. **确认应答与序列号**：TCP传输时将每个字节的数据都进行了编号，TCP传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答，也就是发送ACK报文，报文中包含对应的确认序列号。
3. **超时重传**：发送方在发送完数据后等待一个时间，时间到达没有接收到ACK报文，那么对刚才发送的数据进行重新发送。  
4. **连接管理**：连接管理就是三次握手与四次挥手的过程
5. **流量控制**：TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）。
6. **拥塞控制**：发送端在刚开始就发送大量的数据，那么就可能造成网络拥塞。所以TCP引入了慢启动的机制，在开始发送数据时，先发送少量的数据探路。**快速重传**
7. **ARQ协议**： **自动重传请求**（Automatic Repeat-reQuest，ARQ）。ARQ包括停止等待ARQ协议和连续ARQ协议。
   - 停止等待ARQ协议：每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。
   - 连续ARQ协议：发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。缺点：Go-Back-N（回退 N），需要退回来重传已经发送过的 N 个消息。



#### 流量控制

**TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。**

发送方不能无脑的发数据给接收方，要考虑接收方处理能力。**TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力——确认报文中的窗口字段，控制发送的数据量，这就是所谓的流量控制。**

#### 拥塞控制

前面的流量控制是避免「发送方」的数据填满「接收方」的缓存，但是并不知道网络的中发生了什么。

**拥塞控制**，目的是**避免「发送方」的数据填满整个网络。**

**拥塞窗口 cwnd**是发送方维护的一个的状态变量，它会根据**网络的拥塞程度动态变化的**。

流量控制要求发送方发送的数据不超过接收方的rwnd，拥塞控制要求发送方发送的数据不超过拥塞窗口，因此发送窗口的值是swnd = min(cwnd, rwnd)。

拥塞窗口 cwnd 变化的规则：

- 只要网络中没有出现拥塞，cwnd 就会增大；
- 但网络中出现了拥塞，cwnd 就减少；

**那么怎么知道当前网络是否出现了拥塞呢？**

其实只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是**发生了超时重传，就会认为网络出现了拥塞。**

拥塞控制主要是四个算法：

- **慢开始** 成倍增长
- **拥塞避免**    直到遇到拥塞避免的开始ssthresh，变成线性增长
- **拥塞发生-超时重传**  遇到超时，cwnd 重置为 1  拥塞避免的开始ssthresh设为 cwnd/2。
- **快速恢复** 遇到3ACK  拥塞避免的开始设为cwnd/2，cwnd设为cwnd/2 + 3



### TCP建立连接：三次握手

- 第一次握手：客户端–发送带有 SYN 标志的数据包。
- 第二次握手：服务端–发送带有 SYN/ACK 标志的数据包。
- 第三次握手：客户端–发送带有带有 ACK 标志的数据包。

#### 为什么TCP连接的时候是3次？2次不可以吗？

**1. 同步双方的初始序列号，双方都确认自己与对方的发送与接收是正常的**

**2. 依靠第三次握手才可以阻止重复连接**

在**网络拥堵**情况下，客户端可能连续发送多次 SYN 建立连接的报文，服务端会**建立多个冗余的无效链接，造成不必要的资源浪费。**

为了避免这种情况，需要第三次握手来只确认建立最后发送的连接。如果不是最新的连接，则第三次握手发送的报文是**RST**报文，以此中止这个冗余连接；如果是最新的，则第三次发送的报文是**ACK**报文，通信双方就会成功建立连接。

#### 为什么客户端和服务端的初始序列号 ISN 是不相同的

每次建立连接前重新初始化一个序列号主要是**为了通信双方能够根据序号将不属于本连接的报文段丢弃。**

### TCP断开连接：四次挥手

断开一个 TCP 连接则需要“四次挥手”：

- 客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送
- 服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。服务端进入**CLOSE-WAIT（关闭等待）**
- 服务器-关闭与客户端的连接，发送一个FIN给客户端。
- 客户端-发回 ACK 报文确认，进入**TIME-WAIT（时间等待）**状态。
  - 服务器收到了 ACK 应答报文后，就进入了 CLOSED 状态，至此服务端已经完成连接的关闭。
  - 客户端在经过 **2MSL最长报文段寿命**后，自动进入 CLOSED 状态，至此客户端也完成连接的关闭。

#### 为什么TCP连接的时候是3次，关闭的时候却是4次？

**服务端通常需要等待完成数据的发送和处理**，所以服务端的 ACK 和 FIN 一般都会分开发送，从而比三次握手导致多了一次。

#### 为什么需要 TIME_WAIT 状态？

- **确保服务器端的最后一个确认报文(ACK)能够到达，从而可靠地关闭服务端的连接**。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。
- **防止上一次连接中的包，迷路后重新出现，影响新连接。**等待一段时间是为了让**本连接持续时间内所产生的所有报文都从网络中消失**，使得下一个新的连接不会出现旧的连接请求报文。

#### 为什么 TIME_WAIT 等待的时间是 2MSL？

MSL 是 Maximum Segment Lifetime，**报文最大生存时间**，它是任何报文在网络上存在的最长时间，**超过这个时间报文将被丢弃。 一来一去的最大时间是2MSL**

2MSL 的时间是从**客户端接收到 FIN 后发送 ACK 开始计时的**。如果在 TIME-WAIT 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 2MSL 时间将重新计时。

#### TIME_WAIT 过多有什么危害？端口/内存

危害1：客户端受**端口资源**限制。

危害2：服务端受**系统资源（内存）**限制：系统资源被占满，线程池处理不了那么多一直不断的连接了。

#### 如何处理TIME_WAIT过多

**简单来说，就是打开系统的TIMEWAIT重用和快速回收。还不行的话，尝试修改TCP连接的相关参数（keepalive time，开放端口数，syn队列大小）** 都在`/etc/sysctl.conf`

如果尽量处理了，还是解决不了问题，仍然拒绝服务客户的部分请求，可以采取**负载均衡**来抗这些高并发的短请求。

#### close_wait过多

现象:通过`netstat -napt` 查看TCP连接状态，查看与61616相关的连接状况，发现130多个CLOSE_WAIT

##### close_wait过多原因

**1. socket忙于读写，处理不过来了。**

**2. 写的程序有问题：socket完毕之后，忘记调用close方法。**

##### close_wait过多的解决方案

**参数层面**

**可能是客户端调用close之后挂掉了。可以设置TCP的连接时长keep_alive_time**还有tcp监控连接的频率以及连接没有活动多长时间被迫断开连接。由于KeepLive在Windows操作系统下默认是7200秒，也就是2个小时才清理一次。

**代码层面：**

**第一：使用完socket调用close方法；**

**第二：socket读控制，当读取的长度为0时（读到结尾），立即close；**

第三：如果read返回-1，出现错误，检查error返回码，有三种情况：INTR（被中断，可以继续读取），WOULDBLOCK（表示当前socket_fd文件描述符是非阻塞的，但是现在被阻塞了），AGAIN（表示现在没有数据稍后重新读取）。**如果不是AGAIN，立即close**



## 常见网络攻击

### SYN攻击

**攻击者伪造大量的虚假ip，向Server发送大量SYN报文。**Server在接收到SYN包后，会返回响应，并进入SYN_RECV状态，等待客户端的确认。

**伪造的ip不给予ACK响应**，于是Server以为数据包丢失，不断重发，直到超时。这些伪造的SYN包会**长期占用SYN队列**，使得服务器不能为正常用户服务。引起网络拥堵甚至网络瘫痪。

**当服务器上有大量的半连接且ip为随机的，可以确认是受到了SYN攻击。**

#### 如何避免SYN攻击

**1. 修改 Linux 内核关于SYN队列的参数**

如：修改`SYN_RCVD` 状态连接的最大个数`net.ipv4.tcp_max_syn_backlog`

**2. 设置tcp_syncookies参数**

```sh
vim /etc/sysctl.conf
#加入以下内容：
net.ipv4.tcp_syncookies = 1 
```

**相当于syn等待队列满了之后，新连接不需要进入SYN队列，直接处理。服务端接收到客户端的应答报文时，服务器会检查这个 ACK 包的合法性。如果合法，直接放入到「 Accept 队列」。 **



## [HTTP](docs/network/http.md)

### 一个常见的错误观点

很多文章中还会提到说 HTTP 协议相较于自定义 TCP 报文协议，增加的开销在于连接的建立与断开，但是这个观点已经被否认，下面截取自知乎中一个回答，原回答地址：https://www.zhihu.com/question/41609070/answer/191965937。

>首先要否认一点 HTTP 协议相较于自定义 TCP 报文协议，增加的开销在于连接的建立与断开。HTTP 协议是支持连接池复用的，也就是建立一定数量的连接不断开，并不会频繁的创建和销毁连接。二一要说的是 HTTP 也可以使用 Protobuf 这种二进制编码协议对内容进行编码，因此二者最大的区别还是在传输协议上。

### 请求与响应

客户端发送的   **请求报文**   第一行为请求行，包含了请求方法、URL、协议版本；

#### 常用请求方法

GET、POST、HEAD、PUT、PATCH、DELETE、TRACE

##### Get和Post的区别

get：获取资源，请求能够携带的参数比较少，大小有限制，会在浏览器的URL地址栏显示数据内容，不安全，只读不会改变服务器状态，幂等。

post：传输实体主体，请求能够携带的参数没有限制，大小没有限制，不会在浏览器的URL地址栏显示数据内容，相对安全，可能会改变服务器状态，不幂等。

#### 常用状态码

| 状态码 |               类别               |            含义            |
| :----: | :------------------------------: | :------------------------: |
|  1XX   |  Informational（信息性状态码）   |     接收的请求正在处理     |
|  2XX   |      Success（成功状态码）       |      请求正常处理完毕      |
|  3XX   |   Redirection（重定向状态码）    | 需要进行附加操作以完成请求 |
|  4XX   | Client Error（客户端错误状态码） |     服务器无法处理请求     |
|  5XX   | Server Error（服务器错误状态码） |     服务器处理请求出错     |

常见状态码：

100  表明到目前为止都很正常，请求已收到，正等待后续资源

200 OK - 客户端请求成功

301 **永久重定向** 资源（网页等）被永久转移到其它URL

302  临时跳转，临时性重定向

400 Bad Request - 客户端请求有语法错误，不能被服务器所理解

401 Unauthorized - 请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。

403 Forbidden ：请求被拒绝

404 请求资源不存在，可能是输入了错误的URL

500 服务器内部发生了不可预期的错误

502 网关错误 没配置好AGW或者RPC接口的时候遇到

503 Server Unavailable - 服务器暂时处于超负载或正在进行停机维护，现在无法处理请求，一段时间后可能恢复正常。



303 See Other ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。

-   注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。




### HTTPS

**HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS是运行在SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）之上的HTTP协议，SSL/TLS 运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。**

#### HTTP和HTTPS的区别

端口：http默认是80端口， https默认是443端口

安全性：http是明文传输，https是密文传输

认证：http没有认证，https在建立TCP连接前会进行ssl层的握手，在这个过程中需要认证

成本上：https的证书需要成本，同时加密和解密时对CPU和内存开销增加

#### HTTPS加密

HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。

对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥。

非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。

优缺点：CPU-运算速度快/慢；安全与否。

HTTPS结合两种加密方式，通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。

- **使用非对称密钥加密方式，传输对称密钥加密方式所需要的 Session Key，从而保证安全性;**
- **获取到 Session Key 后，再使用对称密钥加密方式进行通信，从而保证效率。**

**具体过程**

1. 首先客户端通过URL访问服务器**建立SSL连接。**
2. 服务端收到客户端请求后，会将网站支持的**证书信息（证书中包含绑定的公钥）**传送一份给客户端。
3. 客户端验证证书，确保服务端的的公钥没有被调换。
4. 客户端的浏览器根据双方同意的安全等级，获得一致的对称加密密钥，建立**会话密钥**，然后**利用网站的公钥将会话密钥加密**，并传送给服务器。
5. 服务器利用自己的**私钥解密出会话密钥。  这时候两端获取到了相同的密钥**
6. 服务器利用会话密钥加密与客户端之间的通信（对称）。

**什么是认证，什么是CA？**

为了确保浏览器收到的公钥一定是该网站的公钥，使用第三方的证书来对通信方进行认证。CA进行签名：用它的一个hash算法对证书服务器做hash，hash之后用私钥进行加密。将数据，hash算法，签名作为证书发送给客户端。客户端获取到数据后，用CA的公钥解密出hash，再用证书里指明的hash算法对公开密钥做hash，对比两者hash是否相等，若相等，即可保证一定是该网站的公钥。

为什么？其他中间人想掉包公钥的话，没有CA的私钥，没办法进行正确的签名。客户端用CA的公钥解密签名后的hash值和对公钥的hash运算得到的值自然不会相等。

### HTTP1.1/2.0

#### HTTP1.1的改进

**支持长连接。**默认使用长连接Connection: keep-alive。 不需要每次请求都建立一个TCP连接。

**支持流水线方式。** 客户在收到HTTP的响应报文之前就能接着发送新的请求报文。

**支持同时打开多个TCP连接。** 实现了请求/响应的并行。

支持虚拟主机。 在一台物理服务器上可以存在多个虚拟主机。

更多的缓存处理指令。 如：max-age

更多的状态码。如 100

#### HTTP2.0的改进

**多路复用**：即连接共享。多个请求stream共享一个TCP连接，实现**多流并行**而不是依赖建立多个TCP连接。

**二进制分层格式**：HTTP/2.0 将报文分成 HEADERS 帧和 DATA 帧，它们都是二进制格式的。

**服务端推送：**HTTP/2.0 在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。

**首部压缩**：要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输。并且用 Huffman 编码对首部字段进行压缩。



## Socket

**从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。也就是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。**

当应用程序发起 I/O 调用后，会经历两个步骤：

1. 内核等待 I/O 设备准备好数据
2. 内核将数据从内核空间拷贝到用户空间。

同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到在内核把数据拷贝到用户空间。

同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。

IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，**等内核把数据准备好了，用户线程再发起 read 调用。**read 调用的过程（数据从内核空间->用户空间）还是阻塞的。

异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。





### I/O多路复用

多路网络连接复用一个io线程。I/O multiplexing 这里面的 multiplexing 指的其实是在单个线程通过记录跟踪每一个Sock(I/O流)的状态(对应空管塔里面的Fight progress strip槽)来同时管理多个I/O流。

select, poll, epoll 都是I/O多路复用的具体的实现，之所以有这三个鬼存在，其实是他们出现是有先后顺序的。

select 被实现以后，很快就暴露出了很多问题。 

-  select 如果任何一个sock(I/O stream)出现了数据，select 仅仅会返回，但是并**不会告诉你是那个sock上有数据，于是你只能自己一个一个遍历地找**，10几个sock可能还好，要是几万的sock每次都找一遍，这个无谓的开销就颇有海天盛筵的豪气了。
- 一个select 只能监视1024个链接。
- select 会修改传入的参数数组，这个对于一个需要调用很多次的函数，是非常不友好的。
- select 不是线程安全的。

poll 修复了select的很多问题，比如 

- poll 去掉了1024个链接的限制，无上限。
- poll 从设计上来说，不再修改传入数组，不过这个要看你的平台了，所以行走江湖，还是小心为妙。

epoll 可以说是I/O 多路复用最新的一个实现，epoll 修复了poll 和select绝大部分问题, 比如： 

- epoll 现在不仅告诉你sock组里面数据，还会告诉你具体哪个sock有数据，变更触发回调直接读取，你不用自己去找了。 
- epoll 现在是线程安全的。 
- 而且内核态与用户态共享epfd，不需要内核态和用户态的切换



# [设计模式](./docs/system-design/design-pattern/design-principles.md)

## 七大设计原则

| **设计原则**     | **一句话归纳**                                               | **目的**                                       |
| ---------------- | ------------------------------------------------------------ | ---------------------------------------------- |
| **开闭原则**     | **对扩展开放，对修改关闭**                                   | **降低维护带来的新风险**                       |
| **依赖倒置原则** | **高层不应该依赖低层，要面向接口编程**                       | **更利于代码结构的升级扩展**                   |
| **单一职责原则** | **一个类只干一件事，实现类要单一**                           | **便于理解，提高代码的可读性**                 |
| **接口隔离原则** | **一个接口只干一件事，接口要精简单一**                       | **功能解耦，高聚合、低耦合**                   |
| **迪米特法则**   | **不该知道的不要知道，一个类应该保持对其它对象最少的了解，降低耦合度** | **只和朋友交流，不和陌生人说话，减少代码臃肿** |
| **里氏替换原则** | **不要破坏继承体系，子类重写方法功能发生改变，不应该影响父类方法的含义** | **防止继承泛滥**                               |
| **合成复用原则** | **尽量使用组合或者聚合关系实现代码复用，少使用继承**         | **降低代码耦合**                               |

创建型模式分为以下几种。

- 单例（Singleton）模式：为了保证全局使用的是**同一对象**，一方面是安全性考虑，一方面是为了节省资源。
- 原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。了解和 Object 类中的 clone() 方法相关的知识。
- 工厂方法（FactoryMethod）模式：在简单工厂模式的基础上增加了**选择工厂**的维度，需要第一步选择合适的工厂。定义一个用于创建产品的接口，由子类决定生产什么产品。
- 抽象工厂（AbstractFactory）模式：抽象工厂模式有**产品族**的概念。提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。
- 建造者（Builder）模式：专门对付**属性很多**的那种类，为了让代码更优美。将一个复杂对象分解成多个相对简单的部分，然后根据不同需要一步一步创建它们，最后构建成该复杂对象。

结构型模式分为以下 7 种：

1. 代理（Proxy）模式：**增强。**为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、**增强**或修改该对象的一些特性。
2. 适配器（Adapter）模式：**把鸡包装成鸭** 将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口**不兼容**而不能一起工作的那些类能一起工作。
3. 桥接（Bridge）模式：**用组合关系代替继承关系**，将抽象与实现分离，使它们可以独立变化。**解耦。**
4. 装饰（Decorator）模式：方便地给对象**增加一些职责。**每加一个装饰，添加一种功能。
5. 外观（Facade）模式：客户端不需要关注实例化时应该使用哪个实现类，直接调用门面提供的方法就可以了。为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。
6. 享元（Flyweight）模式：享元模式是为了在特定的场景中缓存已经创建的对象，用于提高性能。**用Map**
7. 组合（Composite）模式：**员工有一群员工下属。**用于描述具有层次结构的数据，将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。

**行为型模式**

行为型模式关注的是各个类之间的相互作用，将职责划分清楚，使得我们的代码更加地清晰。

1. 策略（Strategy）模式：**客户属性持有策略的接口，需要时传入不同的策略即可。**定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。
2. 观察者（Observer）模式：**一定有一个地方存放了所有的观察者，然后在事件发生的时候，遍历观察者，调用它们的回调函数。举例：主题里一个list存放observer。**多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。
3. 责任链（Chain of Responsibility）模式：一条单向链表。把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。
4. 模板方法（Template Method）模式：**模板方法只负责定义第一步应该要做什么，第二步应该做什么，第三步应该做什么**，至于怎么做，**选择性部分由子类来实现。**定义一个操作中的算法骨架，将算法的一些步骤延迟到子类中，使得子类在可以不改变该算法结构的情况下重定义该算法的某些特定步骤。
5. 命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。
6. 状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。
7. 中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。
8. 迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。
9. 访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。
10. 备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。
11. 解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。



## 创建型设计模式

### 简单工厂

**只需要传入一个正确的参数，就可以获取所需要的对象，无需知道其创建细节。** 

一般常用`if else`或者`switch`结构，根据传入的不同参数返回不同的生成的对象。

还有一种写法，传入参数为Class对象，类似于JDBC的加载驱动，用Class.forName()方法。

缺点：增加新的产品需要修改工厂类的逻辑判断，**违背开闭原则。**工厂方法可以解决这个缺点

JDK举例：[java.util.Calendar](http://docs.oracle.com/javase/8/docs/api/java/util/Calendar.html#getInstance--)

Spring中的BeanFactory就是简单工厂模式的体现，**根据传入一个唯一的标识来获得Bean对象**，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。

### 工厂方法

定义了一个创建对象的接口，但由实现这个接口的类决定要实例化哪个类。工厂方法把类的实例化操作推迟到子类中进行。

**拓展性强，对于新产品的创建，满足开闭原则，只需多写一个相应的工厂类。**

**缺点：**

- 类的个数容易过多，增加复杂度。

- 抽象产品只能生产一种产品，此弊端可使用抽象工厂模式解决。

JDK举例：[java.net.URLStreamHandlerFactory](http://docs.oracle.com/javase/8/docs/api/java/net/URLStreamHandlerFactory.html#createURLStreamHandler-java.lang.String-)

### 抽象工厂

提供一个接口，用于创建 **相关的对象家族** 。

工厂方法模式中考虑的是一类产品的生产，如电视机厂只生产电视机。而抽象工厂考虑不同等级产品的生产，比如美的工厂即造电视，又造冰箱，空调、洗衣机....

优点：能生产多种产品，如果只有一种产品，则退化成工厂方法。当新增一个产品族时，新创建一个工厂生产这个家族即可，**满足开闭原则。**

缺点：当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改，**不满足开闭原则。**

### 单例

确保一个类只有一个实例，并提供该实例的全局访问点。

使用一个私有构造函数、一个私有静态变量以及一个公有静态函数来实现。

懒汉式-线程不安全：如果没有用到该类，那么就不会实例化 uniqueInstance

```java
public class Singleton {

    private static Singleton uniqueInstance;

    private Singleton() {
    }

    public static Singleton getUniqueInstance() {
        if (uniqueInstance == null) {
            uniqueInstance = new Singleton();
        }
        return uniqueInstance;
    }
}
```

饿汉式-线程安全，直接实例化：

```java
private static Singleton uniqueInstance = new Singleton();
```

懒汉式-线程安全，对懒汉式的公共获取对象的方法加synchronized即可。

```java
public static synchronized Singleton getUniqueInstance() {
    if (uniqueInstance == null) {
        uniqueInstance = new Singleton();
    }
    return uniqueInstance;
}
```

**双重校验锁-线程安全**

加锁操作只需要对实例化那部分的代码进行，只有当 uniqueInstance 没有被实例化时，才需要进行加锁。

```java
public class Singleton {

    //禁止 JVM 的指令重排，防止对象还未初始化就被获取到
    private volatile static Singleton uniqueInstance;

    private Singleton() {
    }

    public static Singleton getUniqueInstance() {
        //避免 uniqueInstance 已经被实例化之后的加锁操作
        if (uniqueInstance == null) {
            synchronized (Singleton.class) {
                //防止多个线程同时进入if，一个获取到锁，释放后另一个获取后又创建对象。
                if (uniqueInstance == null) {
                    uniqueInstance = new Singleton();
                }
            }
        }
        return uniqueInstance;
    }
}
```

静态内部类实现

```java
public class Singleton {

    private Singleton() {
    }

    private static class SingletonHolder {
        private static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getUniqueInstance() {
        return SingletonHolder.INSTANCE;
    }
}
```

当 Singleton 类被加载时，静态内部类 SingletonHolder 没有被加载进内存。只有当调用 `getUniqueInstance()` 方法从而触发 `SingletonHolder.INSTANCE` 时 SingletonHolder 才会被加载，此时初始化 INSTANCE 实例，并且 JVM 能确保 INSTANCE 只被实例化一次。

这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持。

### 原型模式

**用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。**

由于 Java 提供了对象的 clone() 方法，所以用 Java 实现原型模式很简单，只需要实现Cloneable接口即可，重写clone方法返回clone的对象即可。

如何重写clone方法呢？如果只有基本类型或String类型的属性，直接调用super.clone()。如果有引用类型的属性，引用类型也要实现Clonable接口，调用super.clone()之后替换引用类型的属性。

**缺点：**

- 需要为每一个类都配置一个 clone 方法。clone 方法位于类的内部，当对已有类进行改造的时候，需要修改代码，违背了开闭原则。
- 当实现深克隆时，需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来会比较麻烦。因此，深克隆、浅克隆需要运用得当。

### 建造者模式

**将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。**它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。

如果创建简单对象，通常都是使用工厂模式进行创建，而如果创建复杂对象，通常可以考虑使用建造者模式。

可以抽取出共性创建过程，然后交由具体实现类自定义创建流程，使得同样的创建行为可以生产出不同的产品，分离了创建与表示，使创建产品的灵活性大大增加。

由指挥者来调度顺序，实际生产对象的时候，用一个具体建造者，作为属性交给指挥者，指挥者construct中建造调用具体建造者的建造方法，返回对象。

## 结构型设计模式

### 代理模式 🔥

**核心：使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，扩展目标对象的功能。**

#### 静态代理和动态代理的对比

1. **灵活性** ：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！
2. **JVM 层面** ：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。

#### 静态代理

代理对象和目标对象共同实现一个抽象接口，客户通过代理对象来访问目标对象的方法，代理对象控制访问，并且做增强。相当于在目标对象上面包了一层，做一些公共的事情，并且控制对目标对象的访问。

**静态代理中，我们对目标对象的每个方法的增强都是手动完成的，非常不灵活（_比如接口一旦新增加方法，目标对象和代理对象都要进行修改_）且麻烦(_需要对每个目标类都单独写一个代理类_)。**

#### 动态代理——AOP的核心！

**推荐阅读：[知乎-动态代理的作用是什么](https://www.zhihu.com/question/20794107/answer/23330381)**

**原理：通过反射，在代码运行期间动态生成代理类。**

**好处：代理的是接口，一个动态代理可以代理很多类！为所有实现代理接口的目标类提供一些通用的增强方法，比如插入日志-AOP。**

##### JDK 动态代理和 CGLIB 动态代理对比

1. **一个基于接口实现，一个基于类的继承实现** 

   JDK动态代理只能对实现了接口的类生成代理，而不能针对类。

   CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法。因此对于final类或方法，是无法继承的。

2. **JDK效率更高**

   JDK 和 CGLib 都是在运行期生成字节码，JDK 是直接写 Class 字节码，CGLib 使用 ASM 框架写 Class 字节码，Cglib 代理实现更复杂，生成代理类比 JDK 效率低。每一次jdk版本升级，jdk代理效率都得到提升，而CGLIB代理消息确有点跟不上步伐。

**Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。**

##### JDK动态代理

在 Java 动态代理机制中 `InvocationHandler` 接口和 `Proxy` 类是核心。都在`java.lang.reflect`包下面。

**`Proxy`生成动态代理实例，`InvocationHandler`调用处理程序并返回结果。**

`Proxy` 类中使用频率最高的方法是：`newProxyInstance()` ，这个方法主要用来生成一个代理对象。传入目标对象的Classloader，接口，代理对象的`InvocationHandler`，就可以动态生成代理对象。

```java
public static Object newProxyInstance(ClassLoader loader,
                                      Class<?>[] interfaces,
                                      InvocationHandler h)
    throws IllegalArgumentException
```

1. **loader**：被代理类的类加载器，用于加载代理对象。
2. **interfaces** : 被代理类实现的接口；
3. **h** : 实现了 `InvocationHandler` 接口的对象；

```java
public interface InvocationHandler {
    //当你使用代理对象调用方法的时候实际会调用到这个方法
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;
}
```

1. **proxy** :动态生成的代理类
2. **method** : 与代理类对象调用的方法相对应
3. **args** : 当前 method 方法的参数

也就是说：**你通过`Proxy` 类的 `newProxyInstance()` 创建的代理对象在调用方法的时候，实际会调用到实现`InvocationHandler` 接口的类的 `invoke()`方法。**在invoke方法中调用代理对象的同名方法，并且做一些增强：比如在方法执行前后做什么事情。

**动态生成代理类过程**

复制传入的接口，通过接口和类加载器，直接拼接生成字节数组class文件，然后调用native方法defineclass生成clazz对象，创建出了代理的类clazz。然后通过反射获取到代理类clazz的构造函数，通过这个构造函数new一个代理对象，构造函数的参数是InvocationHandler。当代理对象的方法被调用时，会调用InvocationHandler的invoke方法，调用目标对象的方法，并实现增强。

**举例：**

```java
public class ProxyInvocationHandler implements InvocationHandler {
   //被代理类  Object对象，因此可以代理任意类型的对象
   private Object target;

   public void setTarget(Object target) {
       this.target = target;
  }

   //生成代理类
   public Object getProxy(){
       return Proxy.newProxyInstance(this.getClass().getClassLoader(),
               target.getClass().getInterfaces(),this);
  }

   // proxy : 代理类
   // method : 代理类的调用处理程序的方法对象.
   public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
       log(method.getName());
       Object result = method.invoke(target, args);
       return result;
  }

   public void log(String methodName){
       System.out.println("执行了"+methodName+"方法");
  }
}
```

```java
public class Test {
   public static void main(String[] args) {
       //真实对象
       UserServiceImpl userService = new UserServiceImpl();
       //代理对象的调用处理程序
       ProxyInvocationHandler pih = new ProxyInvocationHandler();
       //设置要代理的对象 可以是任意对象！！
       pih.setTarget(userService);
       UserService proxy = (UserService)pih.getProxy(); //动态生成代理类！
       //可以换成被代理类接口中的任意方法！！！
       proxy.delete();  
  }
}
```

##### CGLIB 动态代理

**在 CGLIB 动态代理机制中 `MethodInterceptor` 接口和 `Enhancer` 类是核心。**

通过 `Enhancer`类来动态获取被代理类，当代理类调用方法的时候，实际调用的是 `MethodInterceptor` 中的 `intercept` 方法。

步骤一：自定义 `MethodInterceptor` 并重写 `intercept` 方法，`intercept` 用于拦截增强被代理类的方法，和 JDK 动态代理中的 `invoke` 方法类似；

```java
public interface MethodInterceptor extends Callback{
    // 拦截被代理类中的方法
    public Object intercept(Object obj, java.lang.reflect.Method method, Object[] 	
                            args,MethodProxy proxy) throws Throwable;
}
```

1. **obj** :目标对象（需要增强的对象）
2. **method** :被拦截的方法（需要增强的方法）
3. **args** :方法入参
4. **methodProxy** :用于调用原始方法

步骤二：通过 `Enhancer` 类的`setSuperclass`设置目标对象，`setCallback`传入`MethodInterceptor` 设置回调对象，然后 `create()`创建代理对象；

```java
net.sf.cglib.proxy.Enhancer;
Enhancer enhancer = new Enhancer();
// 设置enhancer对象的父类  也就是被代理的对象
enhancer.setSuperclass(HelloService.class);
// 设置enhancer的回调对象
enhancer.setCallback(new MyMethodInterceptor());
//创建代理对象！
HelloService proxy= (HelloService)enhancer.create();
```

### 适配器模式

适配器模式（Adapter）的定义如下：**将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。**

适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。

**适配器模式和代理模式的异同**

在代码结构上，它们很相似，都需要一个具体的实现类的实例。但是它们的目的不一样，代理模式做的是增强原方法的活；适配器做的是适配的活，为的是提供“**把鸡包装成鸭，然后当做鸭来使用**”，而鸡和鸭它们之间原本没有继承关系。

```java
// 毫无疑问，首先，这个适配器肯定需要 implements Duck，这样才能当做鸭来用
public class CockAdapter implements Duck {
    //内部持有一个鸡
    Cock cock;
    // 构造方法中需要一个鸡的实例，此类就是将这只鸡适配成鸭来用
    public CockAdapter(Cock cock) {
        this.cock = cock;
    }

    // 实现鸭的呱呱叫方法
    @Override
    public void quack() {
        // 内部其实是一只鸡的咕咕叫
        cock.gobble();
    }

    @Override
    public void fly() {
        cock.fly();
    }
}
```

JDK举例：

- [java.util.Arrays#asList()](http://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#asList(T...))
- [java.util.Collections#list()](https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#list-java.util.Enumeration-)
- [java.util.Collections#enumeration()](https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#enumeration-java.util.Collection-)
- [javax.xml.bind.annotation.adapters.XMLAdapter](http://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/adapters/XmlAdapter.html#marshal-BoundType-)

### 桥接

**将抽象与实现分离，使它们可以独立变化。**它是**用组合关系代替继承关系**来实现，从而降低了抽象和实现这两个可变维度的耦合度。

### 装饰

在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式。

装饰者（Decorator）和具体组件（ConcreteComponent）都继承自组件（Component），具体组件的方法实现不需要依赖于其它对象，而**装饰者组合了一个组件(父类)，这样它可以装饰其它装饰者或者具体组件。**所谓装饰，就是把这个装饰者套在被装饰者之上，从而动态扩展被装饰者的功能。装饰者的方法有一部分是自己的，这属于它的功能，然后调用被装饰者的方法实现，从而也保留了被装饰者的功能。

**可以嵌套多个装饰者，从而得到多个装饰者的能力。**

**最典型示例：**

- **java.io.BufferedInputStream(InputStream)**
- **java.io.DataInputStream(InputStream)**

### 外观

提供了一个统一的接口，用来访问子系统中的一群接口，从而让子系统更容易使用。

优点：外观（Facade）模式是“迪米特法则”的典型应用。外部应用程序不用关心内部子系统的具体细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。

缺点：增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。

### 组合

将对象组合成树状的层次结构，用来表示“整体-部分”的关系，使用户对单个对象和组合对象具有一致的访问性。

一个类中包含多个相同类型的属性。

```java
public class Employee {
   private String name;
   ...
   private List<Employee> subordinates; // 下属
}
```

### 享元

Flyweight 是轻量级的意思，享元分开来说就是 共享 元器件，也就是复用已经生成的对象，这种做法当然也就是轻量级的了。

复用对象最简单的方式是，用一个 HashMap 来存放每次新生成的对象。每次需要一个对象的时候，先到 HashMap 中看看有没有，如果没有，再生成新的对象，然后将这个对象放入 HashMap 中。

实例：Java 利用缓存来加速大量小对象的访问时间。

- java.lang.Integer#valueOf(int)
- java.lang.Boolean#valueOf(boolean)
- java.lang.Byte#valueOf(byte)
- java.lang.Character#valueOf(char)



# Spring

所谓的IoC，一句话搞定：**对象由Spring 来创建，管理，装配 !** 

与Mybatis不同，mybatis配置相对复杂，需要用xml配置。但Spring完全可以使用纯注解方式配置。不过没必要刻意去追求某种方式，都只是手段，都学，哪种适合用哪种。

```xml
<bean id="user" class="com.kuang.pojo.User">
    <property name="name" value="kuangshen"/>
</bean>
```

```java
@Test
public void test(){
   ApplicationContext context = new ClassPathXmlApplicationContext("beans.xml");
   //在执行getBean的时候, user已经创建好了 , 通过无参构造
   User user = (User) context.getBean("user");
   //调用对象的方法 .
   user.show();
}
```

- 所有的类都需要装配到bean里面
- 所有的bean都需要通过容器去取
- 容器里取得的bean拿出来就是一个对象



### 依赖注入

- 构造器注入 不常用
- set注入
  - property
  - c命名空间、p命名空间注入
  - 自动装配 autowire byName/byType
- 注解注入



## xml/注解

xml的优势：解耦。修改时，不用改源码，不涉及重新编译和配置。

注解的优势：配置简单，维护方便（找到了类就找到了配置）

jdk1.5开始支持注解，spring2.5开始全面支持注解。选择哪种配置的原则是简化开发和配置方便，而非追求某种技术

### bean定义

```xml
 <bean id="user" class="当前注解的类"/>
```

#### @Component

上面xml配置与`@Component("user")`等价。

**作用：**把资源让 spring 来管理。相当于在 xml 中配置一个 bean。

**属性：**value：指定 bean 的 id。如果不指定 value 属性，默认 bean 的 id 是当前类的类名。首字母小写。

**@Component三个衍生注解**

为了更好的进行分层，Spring可以使用其它三个注解，功能一样，目前使用哪一个功能都一样。

- @Controller：web层
- @Service：service层
- @Repository：dao层

### 属性注入

包含依赖注入，注入其他bean的属性就是依赖注入。

```xml
<property name="" ref="">
<property name="" value="">
```

#### @Autowired

自动按照类型注入。当使用注解注入属性时，set 方法可以省略。它只能注入其他 bean 类型。当有多个类型匹配时，使用要注入的对象变量名称作为 bean 的 id，在 spring 容器查找，找到了也可以注入成功。找不到就报错。

#### @Qualifier

在自动按照类型注入的基础之上，再按照 Bean 的 id 注入。它在给字段注入时不能独立使用，必须和@Autowire 一起使用；但是给方法参数注入时，可以独立使用。

```java
@Autowired 
@Qualifier("happyDog")
```

适用于**面向接口编程，接口可能有多个实现。**

#### @Resource

根据注解的name属性，找id相同的bean注入。可以独立使用。

#### @value

根据注解中的值，注入基本数据类型和 String 类型数据。

### 生命周期/作用范围

```xml
<bean id="" class="" scope="" init-method="" destroy-method=""/>
```

#### @Scope

指定 bean 的作用范围。value：指定范围的值。取值：singleton prototype request session globalsession

#### @PostConstruct 

用于指定初始化方法。

#### @PreDestroy

用于指定销毁方法。



### 纯注解开发

**这种纯Java的配置方式在Springboot中随处可见。**

#### @Configuration

代表当前类是一个 spring 配置类，当创建容器时会从该类上加载注解。

#### @ComponentScan

用于指定 spring 在初始化容器时要扫描的包。

```xml
<context:component-scan base-package="com.itheima"/>
```

#### @Bean

该注解只能写在方法上，表明使用此方法创建一个对象，并且放入 spring 容器。相当于我们之前写的bean标签，这个方法的名字就相当于bean中的id属性，这个方法的返回值，就相当于bean标签中的class属性。

```java
@Configuration
@ComponentScan("com.xsq.pojo")
public class KuangConfig {
    //注册一个bean，就相当于我们之前写的bean标签
    //这个方法的名字就相当于bean中的id属性
    //这个方法的返回值，就相当于bean标签中的class属性
    @Bean
    public User getUser(){
        return new User();//就是返回要注入到bean的对象
    }
}
```

如果完全使用了配置方式去做，**要通过AnnotationConfig 上下文来获取容器，通过配置类的class对象加载！** 

```java
ApplicationContext context = new AnnotationConfigApplicationContext(KuangConfig.class);        
User getUser = (User) context.getBean("getUser");   //传的是方法名
```

#### @PropertySource

用于加载.properties 文件中的配置。例如我们配置数据源时，可以把连接数据库的信息写到properties 配置文件中，就可以使用此注解指定 properties 配置文件的位置。

#### @Import

用于导入其他配置类。类似于配置文件中的 inculde 标签

**属性：**value[]：用于指定其他配置类的字节码



## SpringBoot



# [MyBatis](docs/framework/Mybatis.md)

### JDBC使用流程

1. **加载驱动 Class.forName**
2. **连接数据库 `DriverManager.getConnection`**
3. **获得执行SQL的对象 statement(不安全) `connection.createStatement();` `statement = connection.prepareStatement(sql);`**
4. **执行SQL，获得返回的结果集  ` ResultSet resultSet = statement.executeQuery(sql);`**
5. **释放连接  `resultSet.close(); statement.close(); connection.close();**`

```JAVA
import java.sql.*;

public class JdbcFirstDemo {
    public static void main(String[] args) throws Exception {
        //1. 加载驱动
        Class.forName("com.mysql.jdbc.Driver");

        //2. 用户信息和url
        String url = "jdbc:mysql://localhost:3306/jdbcstudy?useSSL=false&useUnicode=true&characterEncoding=utf8";
        String username = "root";
        String password = "123456";

        //3. 连接成功 数据库对象
        Connection connection = DriverManager.getConnection(url, username, password);

        //4. statement-执行SQL的对象 
        Statement statement = connection.createStatement();

        //5. 执行SQL的对象 去执行SQL 可能存在结果，查看返回结果
        String sql = "select * from users";
        //返回的结果集
        ResultSet resultSet = statement.executeQuery(sql);
        while (resultSet.next()) {
            System.out.println("id=" + resultSet.getObject("id"));
            System.out.println("name=" + resultSet.getObject("name"));
        }

        //6. 释放连接 
        resultSet.close();
        statement.close();
        connection.close();
    }
}
```

```java
//防止SQL注入版本，替换第4步
String sql = "insert into users(id,name,password,email,birthday) values(?,?,?,?,?);";
//防止SQL注入方法。 和Statement的区别：直接把sql作为参数放入
statement = connection.prepareStatement(sql);
//手动给参数赋值  set函数的第一个参数表示第几个?
statement.setInt(1, 7);
statement.setString(2, "hhh");
statement.setString(3, "12312313");
statement.setString(4, "15612318@qq.com");
//注意java Date和sql.Date不一样
statement.setDate(5, new java.sql.Date(System.currentTimeMillis()));
//executeUpdate()才会执行
if (statement.executeUpdate() > 0) {
    System.out.println("插入成功！");
}
```

操作事务

```java
//开启事务
connection.setAutoCommit(false);      

//一组SQL执行完毕，提交事务
connection.commit();
```



### MyBatis和Hibernate区别

Hibernate是全自动化ORM框架，Mybatis是半自动化ORM框架，Mybatis的可定制性更高，更灵活，所以用Mybatis的人更多。

1.Mybatis和hibernate不同，它不完全是一个全自动化ORM（对象关系映射）框架，因为MyBatis需要程序员自己编写Sql语句。**hibernate完全可以通过对象关系模型实现对数据库的操作，拥有完整的JavaBean对象与数据库的映射结构来自动生成sql。而mybatis仅有基本的字段映射，对象数据以及对象实际关系仍然需要通过**手写sql**来实现和管理。**

2.Mybatis直接编写原生态sql，可以严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，因为这类软件需求变化频繁，一但需求变化要求迅速输出成果。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件，则需要自定义多套sql映射文件，工作量大。

3.Hibernate对象/关系映射能力强，数据库无关性和移植性更好，对于关系模型要求高的软件，如果用hibernate开发可以节省很多代码，提高效率。

### #{}和${}的区别是什么

${}是字符串替换，相当于直接显示数据，#{}是预编译处理，相当于对数据加上双引号。

$用于配置文件。#用于mybatis中SQL参数占位符-PreparedStatement。

- `${}`是 Properties 文件中的变量占位符，它可以用于标签属性值和 sql 内部，属于静态文本替换，比如${driver}会被静态替换为`com.mysql.jdbc.Driver`。
- `#{}`是 sql 的参数占位符，MyBatis 会将 sql 中的`#{}`替换为?号，在 sql 执行前会使用 **PreparedStatement 的参数设置方法(set方法)，按序给 sql 的?号占位符设置参数值**，比如 ps.setInt(0, parameterValue)，`#{item.name}` 的取值方式为使用反射从参数对象中获取 item 对象的 name 属性值，相当于 `param.getItem().getName()`。



#### 简述一下Mybatis 的编程步骤

A.创建 SqlSessionFactory

B.通过 SqlSessionFactory 创建 SqlSession

C.通过 sqlsession 执行数据库操作

D.调用 session.commit()提交事务

E.调用 session.close()关闭会话

1、获取sqlSessionFactory对象 一般写在静态语句块中，只在程序启动的时候获取一次。

```java
//classpath下的xml配置文件，一般放在resources目录下
String resource = "mybatis-config.xml"; 
InputStream inputStream = Resources.getResourceAsStream(resource);
sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
```

2、SQL语句的接口实现类变成了一个Mapper配置文件，不再需要繁琐的jdbc java代码，execute\resultSet...

```xml
<!--namespace=绑定一个对应的Dao/Mapper接口-->
<mapper namespace="com.mkx.dao.UserMapper">
    <!--select查询语句-->
    <!--id对应方法的名字，resultType是返回类型，如果返回一个集合，写集合泛型中的类型-->
    <select id="getUserList" resultType="com.mkx.pojo.User">
        select * from user
    </select>
</mapper>
```

3、在配置文件`mybatis-config.xml`中注册

```xml
<mappers>
    <mapper resource="com/mkx/dao/UserMapper.xml"/>
</mappers>
```

就可以写测试程序了：

```java
//传入接口的.class，因为有UserMapper的实现，就可以获得可以执行sql语句的xml配置的对象。
try (SqlSession session = sqlSessionFactory.openSession()) {
    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
    List<User> userList = userMapper.getUserList();
    for (User user : userList) {
        System.out.println(user);
    }
}


//方式二： 不建议
//List<User> list =  sqlSession.selectList("com.mkx.dao.UserDao.getUserList");

//！！每次使用都一定不要忘记关闭SqlSession。应该每一个网络请求，建立一个sqlSession，返回结果后关闭sqlSession。 如果用的try，可以写在finally
sqlSession.close();
```

作用域和生命周期：

**SqlSessionFactoryBuilder：**局部变量，一旦创建了 SqlSessionFactory，就不再需要它了

**SqlSessionFactory：工厂方法模式创建SqlSession**，说白了就是可以想象为 ：数据库连接池

- 一旦被创建就应该在应用的运行期间一直存在，**没有任何理由丢弃它或重新创建另一个实例。** 因此 SqlSessionFactory 的最佳作用域是应用作用域。 
- 最简单的就是使用**单例模式**或者静态单例模式。

**SqlSession**

- 连接到连接池的一个请求！
- SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。
- 用完之后需要赶紧关闭，否则资源被占用。



**MyBatis中接口绑定有几种实现方式,是怎么实现的?**

1. 通过注解绑定，在接口的方法上面加上 @Select@Update等注解里面包含Sql语句来绑定（Sql语句比较简单的时候，推荐注解绑定）

2. 通过xml里面写SQL来绑定, 指定xml映射文件里面的namespace必须为接口的全路径名（SQL语句比较复杂的时候，推荐xml绑定）



#### 使用MyBatis的mapper接口调用时有哪些要求？

1.Mapper接口方法名和mapper.xml中定义的每个sql的id相同；

2.Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同；

3.Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同；

4.Mapper.xml文件中的namespace即是mapper接口的类路径。

### Mapper接口的工作原理

Dao 接口的工作原理是 JDK 动态代理，MyBatis 运行时会使用 JDK 动态代理为 Dao 接口生成代理 proxy 对象，代理对象 proxy 会拦截接口方法，转而执行`MappedStatement`所代表的 sql，然后将 sql 执行结果返回。

 `Mapper`接口，接口的全限名，就是映射文件中的 namespace 的值，接口的方法名，就是映射文件中`MappedStatement`的 id 值，接口方法内的参数，就是传递给 sql 的参数。`Mapper`接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个`MappedStatement`，举例：`com.mybatis3.mappers.StudentDao.findStudentById`，可以唯一找到 namespace 为`com.mybatis3.mappers.StudentDao`下面`id = findStudentById`的`MappedStatement`。在 MyBatis 中，每一个`<select>`、`<insert>`、`<update>`、`<delete>`标签，都会被解析为一个`MappedStatement`对象。

Dao 接口里的方法可以重载，但是Mybatis的XML里面的ID不允许重复。

#### MyBatis 都有哪些 Executor 执行器？它们之间的区别是什么？

答：MyBatis 有三种基本的 Executor 执行器，**`SimpleExecutor`、`ReuseExecutor`、`BatchExecutor`。**

**`SimpleExecutor`：**每执行一次 update 或 select，就开启一个 Statement 对象，用完立刻关闭 Statement 对象。

**``ReuseExecutor`：**执行 update 或 select，以 sql 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后，不关闭 Statement 对象，而是放置于 Map<String, Statement>内，供下一次使用。简言之，就是重复使用 Statement 对象。

**`BatchExecutor`：**执行 update（没有 select，JDBC 批处理不支持 select），将所有 sql 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理。与 JDBC 批处理相同。

作用范围：Executor 的这些特点，都严格限制在 SqlSession 生命周期范围内。



### Mybatis 中一级缓存与二级缓存的区别？

缓存：合理使用缓存是优化中最常见的方法之一，将从数据库中查询出来的数据放入缓存中，下次使用时不必从数据库查询，而是直接从缓存中读取，避免频繁操作数据库，减轻数据库的压力，同时提高系统性能。

**一级缓存是SqlSession级别的缓存：**

Mybatis对缓存提供支持，但是在没有配置的默认情况下，它只开启一级缓存。一级缓存在操作数据库时需要构造sqlSession对象，在对象中有一个数据结构用于存储缓存数据。不同的sqlSession之间的缓存数据区域是互相不影响的。也就是他只能作用在同一个sqlSession中，不同的sqlSession中的缓存是互相不能读取的。

**二级缓存是mapper级别的缓存：**

MyBatis的二级缓存是mapper级别的缓存，它可以提高对数据库查询的效率，以提高应用的性能。**多个SqlSession去操作同一个Mapper的sql语句，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。**

开启二级缓存:

1. mybatis.xml配置文件中加入：

```xml
<settings>    
   <!--开启二级缓存-->    
    <setting name="cacheEnabled" value="true"/>    
</settings>
```

2. 在需要开启二级缓存的mapper.xml中加入cache标签

```xml
<cache/>
```

3. 让使用二级缓存的POJO类实现Serializable接口

```java
public class User implements Serializable {}
```



## XML配置

```xml
<configuration>
    <properties resource="db.properties"/>
    <settings>
        <setting name="logImpl" value="STDOUT_LOGGING"/>
    </settings>
    <environments default="development"> //这里选择默认的，可以有多套环境 比如测试环境test
        <environment id="development"> 
            <transactionManager type="JDBC"/>
            <dataSource type="POOLED">
                <property name="driver" value="${driver}"/>
                <property name="url" value="${url}"/>
                <property name="username" value="${username}"/>
                <property name="password" value="${password}"/>
            </dataSource>

        </environment>
    </environments>
    <mappers>
        <mapper resource="com/mkx/dao/UserMapper.xml"/>
    </mappers>
</configuration>
```

还有一些比如`typeAliases`，`settings`的配置，用的时候查。

#### environment

**transactionManager：**在 MyBatis 中有两种类型的事务管理器（也就是 type="[JDBC|MANAGED]"）。JDBC – 这个配置直接使用了 JDBC 的提交和回滚设施，它依赖从数据源获得的连接来管理事务作用域。MANAGED几乎不会用。

**数据源（dataSource）**：有三种内建的数据源类型（也就是 type="[UNPOOLED|POOLED|JNDI]"）。一般用**POOLED**，除了有上面的property之外，还有池化连接数相关的各种参数。

#### properties

```xml
<properties resource="db.properties"/>
```

通过properties属性来实现引用配置文件。上面的`<property name="driver" value="${driver}"/>`driver变量就是在`db.properties`中配置的。

#### 映射器

告诉 MyBatis 去哪里找映射文件

```xml
<mappers>
    <mapper resource="com/mkx/dao/UserMapper.xml"/>
    <mapper class="com.mkx.dao.UserMapper"/>
    <package name="com.mkx.dao"/>
</mappers>
```

上面三种都可以。

#### plugins插件

- mybatis-generator-core
- mybatis-plus
- 通用mapper



## XML映射文件

### Xml 映射文件中有哪些标签

最常见的 select|insert|update|delete ，`<resultMap>、<parameterMap>、<sql>、<include>、<selectKey>`，加上动态 sql 的 9 个标签，`trim|where|set|foreach|if|choose|when|otherwise|bind`等，其中为 sql 片段标签，通过`<include>`标签引入 sql 片段，`<selectKey>`为不支持自增的主键生成策略标签。

```xml
<!--namespace=绑定一个对应的Dao/Mapper接口  namespace中的包名要和Mapper接口的包名一致-->
<mapper namespace="com.mkx.dao.UserMapper">
    <!--select查询语句-->
    <!--id是对应的namespace中的方法名；resultType是返回类型；parameterType：参数类型-->
    <select id="getUserById" resultType="com.mkx.pojo.User" parameterType="int">
        <!--函数传入了id，这里可以直接取 用#{参数名}-->
        select * from user where id = #{id}
    </select>
    
    <insert id="addUser" parameterType="com.mkx.pojo.User">
        <!--对象中的属性可以直接取出来 com.mkx.pojo.User中定义了id，name，pwd，values后面这里可以直接取-->
        insert into user (id, name, pwd) values (#{id},#{name},#{pwd});
    </insert>
    
    <update id="updateUser" parameterType="com.mkx.pojo.User">
        update user set name = #{name}, pwd=#{pwd} where id=#{id};
    </update>
    
    <delete id="deleteUser" parameterType="int">
        delete from mybatis.user where id = #{id};
    </delete>
</mapper>
```

Mybatis中增删改必须提交事务。回顾JDBC中，是需要自己开启事务的。mybatis是自动开启，必须提交才能执行成功。

```java
....增删改
sqlSession.commit(); //commit之后才会生效。
sqlSession.close();
```

#### 简述 MyBatis 的 Xml 映射文件和 MyBatis 内部数据结构之间的映射关系？

MyBatis 将所有 Xml 配置信息都封装到 All-In-One 重量级对象 Configuration 内部。

在 Xml 映射文件中，`<parameterMap>`标签会被解析为 `ParameterMap` 对象，其每个子元素会被解析为 ParameterMapping 对象。

`<resultMap>`标签会被解析为 `ResultMap` 对象，其每个子元素会被解析为 `ResultMapping` 对象。

**每条语句都转换为`MappedStatement`对象，以namespace+id 为key，存在 `Map<String, MappedStatement>`StatementMap中。每一个`<select>、<insert>、<update>、<delete>`标签均会被解析为 `MappedStatement` 对象，标签内的 sql 会被解析为 BoundSql 对象。**

因此不同xml映射文件的id是可以重复的，namespace+id作为key。

### 当实体类中的属性名和表中的字段名不一样 ，怎么办 ？

输入：parameterType="map"  输出：ResultMap 

第1种： 通过在查询的sql语句中定义字段名的别名，让字段名的别名和实体类的属性名一致。

第2种： 通过来映射字段名和实体类属性名的一一对应的关系。 Map

#### 使用Map传入参数

**假设，我们的实体类，或者数据库中的表，字段或者参数过多，我们应当考虑使用Map。**

上面的XML文件中parameterType使用的User，例如插入语句：后面的values(#{id},#{name},#{pwd})，#{}只能填属性，需要和User的属性一一对应。

如果使用Map，可以不考虑对象的属性，#{}中填Map的key即可。

```xml
int addUser2(Map<String,Object> map);

<!--Map中的key，可以直接取出来  传递map的key-->
<insert id="addUser2" parameterType="map">
    insert into mybatis.user (id, pwd) values (#{userid},#{passWord});
</insert>
```

**用Map方式的好处**：

在应用层不需要创建User对象，创建一个Map，需要什么属性填什么key-value对。如果User有一百个属性，且都不为空，只想修改Update其中的一个属性pwd，创建User对象需要其他99个属性都填上值。但使用Map就不需要，只需要添加一个pwd的key，value填要修改的值就可以了。

**Map传递参数，直接在sql中取出key即可**，key的名字可以自己随便起，传给的字段对了就可以了。

#### ResultMap 

**结果映射——解决Java属性名和数据库字段名不一致的问题**

```xml
<!-- mybatis-config.xml 中 -->
<typeAlias type="com.mkx.pojo.User" alias="User"/>

<!--结果集映射 把UserMap映射为User——映射的关系 -->
<resultMap id="UserMap" type="User">
    <!--column数据库中的字段，property实体类中的属性-->
    <result column="id" property="id"/>
    <result column="name" property="name"/>
    <result column="pwd" property="password"/>
</resultMap>

			<!--这里去掉了resultType属性，用了resultMap之后不需要了-->
<select id="getUserById" resultMap="UserMap">
    select * from mybatis.user where id = #{id}
</select>
```



# 分布式

## RPC



## [消息队列](docs/system-design/mq/message-queue.md)



## Zookeeper

**ZooKeeper 是一个开源的==分布式协调服务==，同时满足CP，具有强一致性。**

==**ZooKeeper 为我们提供了高可用、高性能、稳定的分布式数据一致性解决方案，通常被用于实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、Master 选举、分布式锁和分布式队列等功能。**==

另外，ZooKeeper 将数据保存在内存中，性能是非常棒的。 在“读”多于“写”的应用程序中尤其地高性能，因为“写”会导致所有的服务器间同步状态。（“读”多于“写”是协调服务的典型场景）。



### ZAB原理

`ZAB(ZooKeeper Automic Broadcast)` 原子广播协议，让 `Leader` 问问 `Followers` 是否同意更新，如果超过半数以上的同意那么就进行 `Follower` 和 `Observer` 的更新（和 `Paxos` 一样）。

#### 写操作步骤

通过Leader进行写操作，主要分为五步：

1. 客户端向Leader发起写请求
2. Leader将写请求以Proposal的形式发给所有Follower并等待ACK
3. Follower收到Leader的Proposal后返回ACK
4. Leader得到过半数的ACK（Leader对自己默认有一个ACK）后向所有的Follower和Observer发送Commmit
5. Leader将处理结果返回给客户端

Follower/Observer均可接受写请求，但不能直接处理，收到写请求后，会将写请求转发给Leader处理，然后继续上述12345步骤。

#### 读操作步骤

Leader/Follower/Observer都可直接处理读请求，从本地内存中读取数据并返回给客户端即可。



### Zookeeper实现分布式锁

[七张图】彻底讲清楚ZooKeeper分布式锁的实现原理](https://www.imooc.com/article/284956?block_id=tuijian_wz)



## 分布式事务

[聊聊分布式事务，再说说解决方案](https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html)



# Linux

## 常用命令

```sh
#查看进程 比如查看mysql是否启动了： 
ps -ef | grep mysql
#或者
ps -aux | grep mysql

#查看一下3306端口：
netstat -anp | grep 3306
#结果：
tcp   0  0 0.0.0.0:3306   0.0.0.0:*   LISTEN   2343/mysqld  
```

```sh
#添加环境变量
vim .bash_profile

#插入：
JAVA_HOME=//usr/java/jdk1.8.0_65
PATH=$PATH:$JAVA_HOME/bin  //在PATH的基础上拼接JAVA_HOME/bin

#刷新
source ~/.bash_profile

#通过jar包启动java程序  jar包可以用maven打包
java -jar xxx.jar
```

**外挂配置文件方式启动springboot：** 这样可以优先选择deploy脚本的配置，覆盖jar包中的application.proporties的配置。

```sh
#首先在项目文件夹下新建application proporties文件
vim application.properties
server.port=80   //修改服务端口为80端口

ls
>>>application.properties  xxx.jar

启动的时候选择配置文件
java -jar xxx.jar --spring.config.addition-location=application.properties的路径
#这样启动的java程序就要通过配置文件中的配置80端口--HTTP端口进行访问了
```

后台启动 用nohp + &

```sh
vim deploy.sh

#//启动一个守护线程：不退出应用程序
nohup java -Xms400m -Xmx400m -XX:NewSize=200m -XX:MaxNewSize=200m -jar 
xxx.jar --spring.config.addition-location=application.properties的路径

chmod -R 777 *

#启动：deploy脚本中的jar  后台启动 并且会把原本打印到控制台上的信息追加到nohup.out
./deploy.sh &

#查看最后200行
tail -200f nohup.out
```





# Git

```sh
#移除文件的追踪
git rm --cached file名 #把文件从版本库里移除   -r folder名
vim .gitignore #然后把文件添加到gitignore中，再次commit，push的时候就没有了
```



# Nginx

**nginx高性能原因分析**

1.epoll多路复用 非阻塞式IO操作

2.允许平滑重启

3.协程机制



# 正则表达式

```sh
^：匹配输入字符串的开始位置
+：匹配前面的子表达式一次或多次（大于等于1次）。
$：匹配输入字符串的结束位置。
```





# 综合

## 架构

### 核心要素

高性能、高可用、高并发、伸缩性、拓展性、安全性



### 如何设计一个高并发的服务？

**多线程、缓冲、缓存、异步、分割、分布式、集群、冗余**

**单线程(多路复用)->多核(多线程)->多台服务器(服务集群)**

**缓存**：包括存储在用户的缓存、CDN、反向代理、服务器本地缓存、分布式缓存

**异步**：消息队列

**冗余：**主从同步

存储：[LevelDB的LSM树](https://www.jianshu.com/p/5c846e205f5f) vs B+树



### 你使用过哪些组件或者方法来提升网站性能,可用性以及并发量

1. **提高硬件能力、增加系统服务器**。（当服务器增加到某个程度的时候系统所能提供的并发访问量几乎不变，所以不能根本解决问题）

2. **使用缓存**（本地缓存：本地可以使用JDK自带的 Map、Guava Cache.分布式缓存：Redis、Memcache.本地缓存不适用于提高系统并发量，一般是用处用在程序中。比如Spring是如何实现单例的呢？大家如果看过源码的话，应该知道，S把已经初始过的变量放在一个Map中，下次再要使用这个变量的时候，先判断Map中有没有，这也就是系统中常见的单例模式的实现。）

3. **消息队列** （解耦+削峰+异步）

4. **采用分布式开发** （不同的服务部署在不同的机器节点上，并且一个服务也可以部署在多台机器上，然后利用 Nginx 负载均衡访问。这样就解决了单点部署(All In)的缺点，大大提高的系统并发量）

5. **数据库分库（读写分离）、分表（水平分表、垂直分表）**

6. **采用集群** （多台机器提供相同的服务）

7. **CDN 加速** (将一些静态资源比如图片、视频等等缓存到离用户最近的网络节点)

8. **浏览器缓存**

9. **使用合适的连接池**（数据库连接池、线程池等等）

10. **适当使用多线程进行开发。**

    

### 使用配置文件的好处

**解耦。**



```java
//如果没有导入依赖，运行，出现编译错误：Error:程序包com.mysql.jdbc不存在
DriverManager.registerDriver(new com.mysql.jdbc.Driver());

//通过反射加载驱动类，不再依赖某个具体的驱动类。尽管没有依赖的时候还是不能得到正确结果，但程序在编译期没有任何问题，抛出的是exception异常，程序可以一直运行下去。
Class.forName("com.mysql.jdbc.Driver");


//上面的Class.forName("com.mysql.jdbc.Driver")也存在一个缺陷，和com.mysql.jdbc.Driver绑死了，如果要换一个数据库，换成Oracle的，还得到这里来修改。
//更好的方法是通过读取配置文件来获取要创建的对象全限定类名，然后再使用反射创建对象。
```





写程序应该80%的时间在思考，20%的时间敲代码。不应该反过来